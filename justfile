#!/usr/bin/env just --justfile

main_crate := 'varnish'
packages := '--workspace'  # All crates in the workspace
features := '--all-features'  # Enable all features
targets := '--all-targets'  # For all targets (lib, bin, tests, examples, benches)

# which version of Varnish to install by default. Update the `supported_varnish_vers` variable below.
default_varnish_ver := '8.0'

# Make sure to update CI with the changes.  The versions with 'r' suffix are Varnish Plus versions - must have all 4 numbers.
supported_varnish_vers := '8.0  7.7  7.7.0  6.0  6.0.14r3'

# if running in CI, treat warnings as errors by setting RUSTFLAGS and RUSTDOCFLAGS to '-D warnings' unless they are already set
# Use `CI=true just ci-test` to run the same tests as in GitHub CI.
# Use `just env-info` to see the current values of RUSTFLAGS and RUSTDOCFLAGS
ci_mode := if env('CI', '') != '' {'1'} else {''}
# cargo-binstall needs a workaround due to caching
# ci_mode might be manually set by user, so re-check the env var
binstall_args := if env('CI', '') != '' {'--no-confirm --no-track --disable-telemetry'} else {''}
export RUSTFLAGS := env('RUSTFLAGS', if ci_mode == '1' {'-D warnings'} else {''})
export RUSTDOCFLAGS := env('RUSTDOCFLAGS', if ci_mode == '1' {'-D warnings'} else {''})
export RUST_BACKTRACE := env('RUST_BACKTRACE', if ci_mode == '1' {'1'} else {''})

@_default:
    {{just_executable()}} --list

# Run integration tests and save its output as the new expected output
@bless *args='-p varnish-macros -p varnish':  (cargo-install 'cargo-insta')
    # Ignore unreferenced snapshots because they are generated by different Varnish versions
    @TRYBUILD=overwrite cargo insta test --accept --unreferenced=ignore {{features}} {{args}}

# Run tests on all targets listed in CI, and accept their results
bless-all:
    #!/usr/bin/env bash
    set -euo pipefail
    # delete content of snapshots*/ dirs, but not the directories themselves
    for dir in varnish/snapshots*; do
        [ -d "$dir" ] || continue
        (cd "$dir" && rm -rf *)
    done
    for ver in {{supported_varnish_vers}}; do
        echo "--------- Updating test results for Varnish $ver"
        {{just_executable()}} docker-run $ver "just bless"
    done

# Build the project with just the default and all features
build:
    cargo build {{packages}} {{features}} $({{just_executable()}} get-package-exclude-args)
    cargo build {{packages}} {{features}} {{targets}} $({{just_executable()}} get-package-exclude-args)

# Quick compile without building a binary
check:
    cargo check {{packages}} {{features}} {{targets}} $({{just_executable()}} get-package-exclude-args)

# Generate code coverage report to upload to codecov.io
ci-coverage: env-info && \
            (coverage '--codecov --output-path target/llvm-cov/codecov.info')
    # ATTENTION: the full file path above is used in the CI workflow
    mkdir -p target/llvm-cov

# Run all tests as expected by CI
ci-test: env-info test-fmt build clippy test && assert-git-is-clean

# Run tests only relevant to the latest Varnish version
ci-test-latest: ci-test test-doc

# Run minimal subset of tests to ensure compatibility with MSRV
ci-test-msrv: env-info test

# Clean all build artifacts
clean:
    cargo clean
    rm -f Cargo.lock

# Clean all build artifacts and docker cache
clean-all: clean
    rm -rf docker/.cache/*
    touch docker/.cache/empty_file

# Run cargo clippy to lint the code
clippy *args:
    cargo clippy {{packages}} {{features}} {{targets}} $({{just_executable()}} get-package-exclude-args) {{args}}

# Generate code coverage report. Will install `cargo llvm-cov` if missing.
coverage *args='--no-clean --open':  (cargo-install 'cargo-llvm-cov')
    #!/usr/bin/env bash
    set -euo pipefail
    find . -name '*.profraw' | xargs rm
    rm -rf ./target/debug/coverage
    export LLVM_PROFILE_FILE="varnish-%p-%m.profraw"
    export RUSTFLAGS="-Cinstrument-coverage"
    cargo build {{packages}} {{features}} {{targets}}
    cargo test {{packages}} {{features}} {{targets}}
    grcov . -s . --binary-path ./target/debug/ -t html --branch --ignore-not-existing -o ./target/debug/coverage/
    open ./target/debug/coverage/index.html
    #
    # TODO: use llvm-cov instead:
    # cargo llvm-cov {{packages}} {{features}} {{targets}} --include-build-script $({{just_executable()}} get-package-exclude-args) {{args}}

docker-run version=default_varnish_ver *args='':  (docker-build-ver version) (docker-run-ver version args)

# Build and open code documentation
docs *args='--open':
    DOCS_RS=1 cargo doc --no-deps {{args}} {{packages}}

# Print environment info
env-info: && env-varnish-version
    @echo "Running for '{{main_crate}}' crate {{if ci_mode == '1' {'in CI mode'} else {'in dev mode'} }} on {{os()}} / {{arch()}}"
    @echo "PWD $(pwd)"
    {{just_executable()}} --version
    rustc --version
    cargo --version
    rustup --version
    @echo "RUSTFLAGS='$RUSTFLAGS'"
    @echo "RUSTDOCFLAGS='$RUSTDOCFLAGS'"
    @echo "RUST_BACKTRACE='$RUST_BACKTRACE'"

env-varnish-version:  get-varnish-version
    #!/usr/bin/env bash
    set -euo pipefail
    SNAPSHOT_DIR="varnish/snapshots$({{just_executable()}} get-varnish-version print)"
    if [ -d "$SNAPSHOT_DIR" ]; then
        echo "Using snapshots from $SNAPSHOT_DIR"
    else
        >&2 echo "#################### ATTENTION ####################"
        >&2 echo "WARNING: No snapshots found at $SNAPSHOT_DIR"
        >&2 echo "Consider running 'just bless' to re-generate them."
        >&2 echo "If an older patch snapshot version exists,"
        >&2 echo "consider symlinking to it with something like this:"
        >&2 echo "    cd varnish  &&  ln -s -r snapshots7.7.1 snapshots7.7.2"
    fi

# Reformat all code `cargo fmt`. If nightly is available, use it for better results
fmt:
    #!/usr/bin/env bash
    set -euo pipefail
    if (rustup toolchain list | grep nightly && rustup component list --toolchain nightly | grep rustfmt) &> /dev/null; then
        echo 'Reformatting Rust code using nightly Rust fmt to sort imports'
        cargo +nightly fmt --all -- --config imports_granularity=Module,group_imports=StdExternalCrate
    else
        echo 'Reformatting Rust with the stable cargo fmt.  Install nightly with `rustup install nightly` for better results'
        cargo fmt --all
    fi

# Get any package's field from the metadata
get-crate-field field package=main_crate:  (assert-cmd 'jq')
    cargo metadata --format-version 1 | jq -e -r '.packages | map(select(.name == "{{package}}")) | first | .{{field}} // error("Field \"{{field}}\" is missing in Cargo.toml for package {{package}}")'

# Get the minimum supported Rust version (MSRV) for the crate
get-msrv package=main_crate:  (get-crate-field 'rust_version' package)

# Get the version of Varnish installed on the system. If a version arg is provided, check that the installed version is at least that version. If param is 'print', just print the installed version.
get-varnish-version $required_version='':
    #!/usr/bin/env bash
    set -euo pipefail
    VARNISH_VER=$(dpkg-query -W -f='${source:Upstream-Version}\n' varnish-dev || echo "unknown")
    # try with varnish-plus-dev
    if [ -z "$VARNISH_VER" ]; then
        VARNISH_VER=$(dpkg-query -W -f='${source:Upstream-Version}\n' varnish-plus-dev || echo "unknown")
    fi
    if [ "$VARNISH_VER" = "unknown" -o -z "$VARNISH_VER" ]; then
        echo "ERROR: varnish-dev package was not found"
        exit 1
    elif [ "$required_version" = 'print' ]; then
        echo "$VARNISH_VER"
    elif [ -n "$required_version" ]; then
        if [ "$(printf "$required_version\n$VARNISH_VER" | sort -V | head -n1)" != "$required_version" ]; then
            echo "ERROR: Varnish version $required_version is required, but $VARNISH_VER is installed."
            exit 1
        else
            echo "Found varnish-dev package v$VARNISH_VER >= $required_version"
        fi
    else
        echo "Found varnish-dev package v$VARNISH_VER"
    fi

# Find the minimum supported Rust version (MSRV) using cargo-msrv extension, and update Cargo.toml
msrv:  (cargo-install 'cargo-msrv')
    cargo msrv find --write-msrv --ignore-lockfile {{features}} --min 1.77 --component rustfmt -- {{just_executable()}} ci-test-msrv

# Run cargo-release
release *args='':  (cargo-install 'release-plz')
    release-plz {{args}}

# Check semver compatibility with prior published version. Install it with `cargo install cargo-semver-checks`
semver *args:  (cargo-install 'cargo-semver-checks')
    cargo semver-checks {{features}} {{args}}

# Run all unit and integration tests
test *args: build
    cargo test {{packages}} {{features}} {{targets}} $({{just_executable()}} get-package-exclude-args) {{args}}
    cargo test --doc {{packages}} {{features}}

# Test documentation generation
test-doc:  (docs '')

# Test code formatting
test-fmt:
    cargo fmt --all -- --check

# Find unused dependencies. Install it with `cargo install cargo-udeps`
udeps:  (cargo-install 'cargo-udeps')
    cargo +nightly udeps {{packages}} {{features}} {{targets}}

# Update all dependencies, including breaking changes. Requires nightly toolchain (install with `rustup install nightly`)
update:
    cargo +nightly -Z unstable-options update --breaking
    cargo update

# Ensure that a certain command is available
[private]
assert-cmd command:
    @if ! type {{command}} > /dev/null; then \
        echo "Command '{{command}}' could not be found. Please make sure it has been installed on your computer." ;\
        exit 1 ;\
    fi

# Make sure the git repo has no uncommitted changes
[private]
assert-git-is-clean:
    @if [ -n "$(git status --untracked-files --porcelain)" ]; then \
      >&2 echo "ERROR: git repo is no longer clean. Make sure compilation and tests artifacts are in the .gitignore, and no repo files are modified." ;\
      >&2 echo "######### git status ##########" ;\
      git status ;\
      git --no-pager diff ;\
      exit 1 ;\
    fi

# Check if a certain Cargo command is installed, and install it if needed
[private]
cargo-install $COMMAND $INSTALL_CMD='' *args='':
    #!/usr/bin/env bash
    set -euo pipefail
    if ! command -v $COMMAND > /dev/null; then
        echo "$COMMAND could not be found. Installing..."
        if ! command -v cargo-binstall > /dev/null; then
            set -x
            cargo install ${INSTALL_CMD:-$COMMAND} --locked {{args}}
            { set +x; } 2>/dev/null
        else
            set -x
            cargo binstall ${INSTALL_CMD:-$COMMAND} {{binstall_args}} --locked {{args}}
            { set +x; } 2>/dev/null
        fi
    fi

# Build a Docker image with the given Varnish version
[private]
docker-build-ver version=default_varnish_ver:
    docker build \
           --progress=plain \
           -t "varnish-img-{{version}}" \
           {{ '--build-arg VARNISH_VERSION=' + version }} \
           --build-arg USER_UID=$(id -u) \
           --build-arg USER_GID=$(id -g) \
           -f docker/Dockerfile \
           .

# Start docker container with the given varnish version
[private]
docker-run-ver version *args:
    mkdir -p docker/.cache/{{version}}
    touch docker/.cache/{{version}}/.bash_history
    docker run --rm -it \
        -v "$PWD:/app/" \
        -v "$PWD/docker/.cache/{{version}}:/home/user/.cache" \
        -v "$PWD/docker/.cache/{{version}}/.bash_history:/home/user/.bash_history" \
        varnish-img-{{version}} {{args}}

# Get the `--exclude <SPEC>` parameter for the cargo build/test/... command, depending on the installed version of Varnish
[private]
get-package-exclude-args:
    #!/usr/bin/env bash
    set -euo pipefail
    if {{just_executable()}} get-varnish-version 7.0 > /dev/null 2> /dev/null ; then
        echo ""
    else
        EXCLUDE="--exclude vmod_be --exclude vmod_vfp --exclude vmod_vdp --exclude vmod_test"
        >&2 echo "INFO: Due to older Varnish, running with: $EXCLUDE"
        echo "$EXCLUDE"
    fi

# Install Varnish from packagecloud.io. This could be damaging to your system - use with caution. Pass non-empty `debug` argument to skip the installation.
[private]
install-varnish version=default_varnish_ver debug='':
    #!/usr/bin/env bash
    set -euo pipefail

    # Assumes major and minor are one digit each. Two digits without dots are treated as (major.minor).
    #  60 or 6.0 -> varnishcache/varnish60lts
    #        7.1 -> varnishcache/varnish71
    #   6.0.14r3 -> varnishplus/60-enterprise

    # Convert version to a tag name used as URL portion
    URL_REPO='{{ if version =~ '^\d\.\d\.\d+r\d+$' { \
        'varnishplus/' + replace_regex(version, '^(\d)\.(\d)\..*$', '$1$2') + '-enterprise' \
    } else if version =~ '^(\d\d|\d(\.\d(\.\d+)?)?)$' { \
        'varnishcache/varnish' + replace_regex(replace_regex(replace_regex(replace_regex(replace_regex(version, \
        '^(\d)(\d)$', '$1.$2') \
        , '^(\d\.\d)(\..*)$', '$1') \
        , '^(\d)$', '$1.0') \
        , '^(\d)\.(\d)$', '$1$2') \
        , '^60$', '60lts') \
    } else { \
      error('Invalid version "' + version + '"') \
    } }}'

    # Policy name is either 'varnish' or 'varnish-plus'
    POLICY='{{ if version =~ '^\d\.\d\.\d+r\d+$' { 'varnish-plus' } else { 'varnish' } }}'

    # Ensure version is valid and convert it to an apt package search string. Assumes major and minor parts are one digit. Two digits are treated as (major.minor).
    PATTERN='{{ if version =~ '^\d\.\d\.\d+r\d+$' { \
        version + '*' \
    } else { \
        replace_regex(replace_regex(replace_regex(version, \
              '^(\d)(\d)$', '$1.$2') \
            , '^(\d\.\d\.\d)$', '$1-') \
            , '^(\d(\.\d)*)$', '$1.') \
        + '*' \
    } }}'

    echo "Installing Varnish '{{version}}' (url_repo='$URL_REPO', pattern='$PATTERN') from packagecloud.io"
    {{ if debug != '' {'exit 0'} else {''} }}

    set -x
    curl -sSf "https://packagecloud.io/install/repositories/$URL_REPO/script.deb.sh" | sudo bash

    {{ if version =~ '^\d\.\d\.\d+r\d+$' {''} else { '''
        echo -e 'Package: varnish varnish-dev\nPin: origin "packagecloud.io"\nPin-Priority: 1001' | sudo tee /etc/apt/preferences.d/varnish
        cat /etc/apt/preferences.d/varnish
    ''' } }}

    sudo apt-cache policy "${POLICY}"
    sudo apt-get install -y "${POLICY}=$PATTERN" "${POLICY}-dev=$PATTERN"
