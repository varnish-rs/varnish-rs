/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &::std::ffi::CStr = c"$DARWIN_EXTSN";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __has_bounds_safety_attributes: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_KERNELKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_13_7: u32 = 130700;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_14_6: u32 = 140600;
pub const __MAC_14_7: u32 = 140700;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __MAC_15_3: u32 = 150300;
pub const __MAC_15_4: u32 = 150400;
pub const __MAC_15_5: u32 = 150500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_17_6: u32 = 170600;
pub const __IPHONE_17_7: u32 = 170700;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __IPHONE_18_3: u32 = 180300;
pub const __IPHONE_18_4: u32 = 180400;
pub const __IPHONE_18_5: u32 = 180500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_10_6: u32 = 100600;
pub const __WATCHOS_10_7: u32 = 100700;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __WATCHOS_11_3: u32 = 110300;
pub const __WATCHOS_11_4: u32 = 110400;
pub const __WATCHOS_11_5: u32 = 110500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_17_6: u32 = 170600;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __TVOS_18_3: u32 = 180300;
pub const __TVOS_18_4: u32 = 180400;
pub const __TVOS_18_5: u32 = 180500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_8_6: u32 = 80600;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __BRIDGEOS_9_3: u32 = 90300;
pub const __BRIDGEOS_9_4: u32 = 90400;
pub const __BRIDGEOS_9_5: u32 = 90500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_23_6: u32 = 230600;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __DRIVERKIT_24_3: u32 = 240300;
pub const __DRIVERKIT_24_4: u32 = 240400;
pub const __DRIVERKIT_24_5: u32 = 240500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_1_3: u32 = 10300;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const __VISIONOS_2_3: u32 = 20300;
pub const __VISIONOS_2_4: u32 = 20400;
pub const __VISIONOS_2_5: u32 = 20500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_13_7: u32 = 130700;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_14_6: u32 = 140600;
pub const MAC_OS_VERSION_14_7: u32 = 140700;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const MAC_OS_VERSION_15_3: u32 = 150300;
pub const MAC_OS_VERSION_15_4: u32 = 150400;
pub const MAC_OS_VERSION_15_5: u32 = 150500;
pub const __AVAILABILITY_VERSIONS_VERSION_HASH: u32 = 93585900;
pub const __AVAILABILITY_VERSIONS_VERSION_STRING: &::std::ffi::CStr = c"Local";
pub const __AVAILABILITY_FILE: &::std::ffi::CStr = c"AvailabilityVersions.h";
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const SO_BINDTODEVICE: u32 = 4404;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const TIME_UTC: u32 = 1;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const VRT_INTEGER_MAX: u64 = 999999999999999;
pub const VRT_INTEGER_MIN: i64 = -999999999999999;
pub const VRT_MAJOR_VERSION: u32 = 22;
pub const VRT_MINOR_VERSION: u32 = 0;
pub const STRANDS_MAGIC: u32 = 1566224790;
pub const VRT_BLOB_MAGIC: u32 = 3776240542;
pub const VRT_NULL_BLOB_TYPE: u32 = 4208873376;
pub const VRT_CTX_MAGIC: u32 = 1807282395;
pub const VRT_ENDPOINT_MAGIC: u32 = 3426849607;
pub const VRT_BACKEND_MAGIC: u32 = 1201262188;
pub const VRT_BACKEND_PROBE_MAGIC: u32 = 2224653456;
pub const VDI_METHODS_MAGIC: u32 = 1321256123;
pub const DIRECTOR_MAGIC: u32 = 859190557;
pub const VMOD_PRIV_METHODS_MAGIC: u32 = 3466985369;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const VSPLAY_NEGINF: i32 = -1;
pub const VSPLAY_INF: u32 = 1;
pub const VRBT_STRICT_HST: u32 = 0;
pub const VRBT_NEGINF: i32 = -1;
pub const VRBT_INF: u32 = 1;
pub const VSL_CLASS: &::std::ffi::CStr = c"Log";
pub const VSL_SEGMENTS: u32 = 8;
pub const VSL_CLIENTMARKER: u64 = 4611686018427387904;
pub const VSL_BACKENDMARKER: i64 = -9223372036854775808;
pub const VSL_IDENTMASK: u64 = 2251799813685247;
pub const VSL_LENMASK: u32 = 65535;
pub const VSL_VERMASK: u32 = 3;
pub const VSL_VERSHIFT: u32 = 16;
pub const VSL_IDMASK: u32 = 255;
pub const VSL_IDSHIFT: u32 = 24;
pub const VSL_OVERHEAD: u32 = 3;
pub const VSL_VERSION_2: u32 = 0;
pub const VSL_VERSION_3: u32 = 1;
pub const SLT__MAX: u32 = 256;
pub const NODEF_NOTICE: &::std::ffi::CStr = c"NB: This log record is masked by default.\n\n";
pub const NOSUP_NOTICE : & :: std :: ffi :: CStr = c"NOTE: This tag is currently not in use in the Varnish log.\nIt is mentioned here to document legacy versions of the log,\nor reserved for possible use in future versions.\n\n" ;
pub const HEADER_NOTICE : & :: std :: ffi :: CStr = c"NOTE: HTTP header fields are free form records and not strictly\nmade of 2 fields. Accessing a specific header with the prefix\nnotation helps treating the header value as a single string.\n\n" ;
pub const SLT_F_UNUSED: u32 = 1;
pub const SLT_F_UNSAFE: u32 = 2;
pub const SLT_F_BINARY: u32 = 4;
pub const STREAM_CLOSE_MAGIC: u32 = 3363424573;
pub const DIGEST_LEN: u32 = 32;
pub const WS_ID_SIZE: u32 = 4;
pub const WS_MAGIC: u32 = 905626964;
pub const HTTP_MAGIC: u32 = 1680389577;
pub const HDF_FILTER: u32 = 1;
pub const WORKER_MAGIC: u32 = 1670491599;
pub const BOC_MAGIC: u32 = 1892254838;
pub const OBJCORE_MAGIC: u32 = 1294996226;
pub const BUSYOBJ_MAGIC: u32 = 599348583;
pub const REQTOP_MAGIC: u32 = 1476123218;
pub const REQ_MAGIC: u32 = 4215979885;
pub const SESS_MAGIC: u32 = 741317722;
pub const HTTPH_R_PASS: u32 = 1;
pub const HTTPH_R_FETCH: u32 = 2;
pub const HTTPH_A_INS: u32 = 4;
pub const HTTPH_A_PASS: u32 = 8;
pub const HTTPH_C_SPECIFIC: u32 = 16;
pub const P: u32 = 1;
pub const F: u32 = 2;
pub const I: u32 = 4;
pub const S: u32 = 8;
pub const K: u32 = 16;
pub const OBJ_ITER_FLUSH: u32 = 1;
pub const OBJ_ITER_END: u32 = 2;
pub const VSCARAB_MAGIC: u32 = 97155760;
pub const VSCARAB_F_END: u32 = 1;
pub const VSCARET_MAGIC: u32 = 2619293051;
pub const VCLDIR_MAGIC: u32 = 3211947133;
pub const VDIR_FLG_NOREFCNT: u32 = 1;
pub const VFP_ENTRY_MAGIC: u32 = 3190988839;
pub const VFP_CTX_MAGIC: u32 = 1641665509;
pub const VDP_ENTRY_MAGIC: u32 = 893302657;
pub const VDP_CTX_MAGIC: u32 = 3998227959;
pub const VMOD_ABI_Version: &::std::ffi::CStr =
    c"Varnish 8.0.0 71d4d75665f4d1949f7eeca28092a12df7037f3a";
pub const VSB_MAGIC: u32 = 1250090378;
pub const VSB_FIXEDLEN: u32 = 0;
pub const VSB_AUTOEXTEND: u32 = 1;
pub const VSB_USRFLAGMSK: u32 = 65535;
pub const VSB_DYNAMIC: u32 = 65536;
pub const VSB_FINISHED: u32 = 131072;
pub const VSB_DYNSTRUCT: u32 = 524288;
pub const VSB_QUOTE_PLAIN: u32 = 0;
pub const VSB_QUOTE_JSON: u32 = 2;
pub const VSB_QUOTE_HEX: u32 = 4;
pub const VSB_QUOTE_CSTR: u32 = 8;
pub const VSB_QUOTE_UNSAFE: u32 = 16;
pub const VSB_QUOTE_NONL: u32 = 1;
pub const VSB_QUOTE_ESCHEX: u32 = 32;
pub const VSM_n_USAGE: &::std::ffi::CStr = c"[-n varnish_name]";
pub const VSM_t_USAGE: &::std::ffi::CStr = c"[-t <seconds|off>]";
pub const VSM_MGT_RUNNING: u32 = 2;
pub const VSM_MGT_CHANGED: u32 = 4;
pub const VSM_MGT_RESTARTED: u32 = 8;
pub const VSM_WRK_RUNNING: u32 = 512;
pub const VSM_WRK_CHANGED: u32 = 1024;
pub const VSM_WRK_RESTARTED: u32 = 2048;
pub const VSM_MGT_MASK: u32 = 255;
pub const VSM_WRK_MASK: u32 = 65280;
pub const HTTP_CONN_MAGIC: u32 = 1041886673;
pub type __int8_t = ::std::ffi::c_schar;
pub type __uint8_t = ::std::ffi::c_uchar;
pub type __int16_t = ::std::ffi::c_short;
pub type __uint16_t = ::std::ffi::c_ushort;
pub type __int32_t = ::std::ffi::c_int;
pub type __uint32_t = ::std::ffi::c_uint;
pub type __int64_t = ::std::ffi::c_longlong;
pub type __uint64_t = ::std::ffi::c_ulonglong;
pub type __darwin_intptr_t = ::std::ffi::c_long;
pub type __darwin_natural_t = ::std::ffi::c_uint;
pub type __darwin_ct_rune_t = ::std::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::ffi::c_char; 128usize],
    pub _mbstateL: ::std::ffi::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::ffi::c_long;
pub type __darwin_size_t = ::std::ffi::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::ffi::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::ffi::c_int;
pub type __darwin_clock_t = ::std::ffi::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::ffi::c_long;
pub type __darwin_time_t = ::std::ffi::c_long;
pub type u_int8_t = ::std::ffi::c_uchar;
pub type u_int16_t = ::std::ffi::c_ushort;
pub type u_int32_t = ::std::ffi::c_uint;
pub type u_int64_t = ::std::ffi::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::ffi::c_uint;
pub type __darwin_fsfilcnt_t = ::std::ffi::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::ffi::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::ffi::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::ffi::c_void)>,
    pub __arg: *mut ::std::ffi::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::ffi::c_long,
    pub __opaque: [::std::ffi::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::ffi::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::ffi::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::ffi::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_char = ::std::ffi::c_uchar;
pub type u_short = ::std::ffi::c_ushort;
pub type u_int = ::std::ffi::c_uint;
pub type u_long = ::std::ffi::c_ulong;
pub type ushort = ::std::ffi::c_ushort;
pub type uint = ::std::ffi::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::ffi::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
unsafe extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::ffi::c_int,
        arg2: *const ::std::ffi::c_void,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::ffi::c_void,
    pub iov_len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iovec"][::std::mem::size_of::<iovec>() - 16usize];
    ["Alignment of iovec"][::std::mem::align_of::<iovec>() - 8usize];
    ["Offset of field: iovec::iov_base"][::std::mem::offset_of!(iovec, iov_base) - 0usize];
    ["Offset of field: iovec::iov_len"][::std::mem::offset_of!(iovec, iov_len) - 8usize];
};
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::ffi::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sa_endpoints"][::std::mem::size_of::<sa_endpoints>() - 40usize];
    ["Alignment of sa_endpoints"][::std::mem::align_of::<sa_endpoints>() - 8usize];
    ["Offset of field: sa_endpoints::sae_srcif"]
        [::std::mem::offset_of!(sa_endpoints, sae_srcif) - 0usize];
    ["Offset of field: sa_endpoints::sae_srcaddr"]
        [::std::mem::offset_of!(sa_endpoints, sae_srcaddr) - 8usize];
    ["Offset of field: sa_endpoints::sae_srcaddrlen"]
        [::std::mem::offset_of!(sa_endpoints, sae_srcaddrlen) - 16usize];
    ["Offset of field: sa_endpoints::sae_dstaddr"]
        [::std::mem::offset_of!(sa_endpoints, sae_dstaddr) - 24usize];
    ["Offset of field: sa_endpoints::sae_dstaddrlen"]
        [::std::mem::offset_of!(sa_endpoints, sae_dstaddrlen) - 32usize];
};
impl Default for sa_endpoints {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::ffi::c_int,
    pub l_linger: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of linger"][::std::mem::size_of::<linger>() - 8usize];
    ["Alignment of linger"][::std::mem::align_of::<linger>() - 4usize];
    ["Offset of field: linger::l_onoff"][::std::mem::offset_of!(linger, l_onoff) - 0usize];
    ["Offset of field: linger::l_linger"][::std::mem::offset_of!(linger, l_linger) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of so_np_extensions"][::std::mem::size_of::<so_np_extensions>() - 8usize];
    ["Alignment of so_np_extensions"][::std::mem::align_of::<so_np_extensions>() - 4usize];
    ["Offset of field: so_np_extensions::npx_flags"]
        [::std::mem::offset_of!(so_np_extensions, npx_flags) - 0usize];
    ["Offset of field: so_np_extensions::npx_mask"]
        [::std::mem::offset_of!(so_np_extensions, npx_mask) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::ffi::c_char; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr"][::std::mem::size_of::<sockaddr>() - 16usize];
    ["Alignment of sockaddr"][::std::mem::align_of::<sockaddr>() - 1usize];
    ["Offset of field: sockaddr::sa_len"][::std::mem::offset_of!(sockaddr, sa_len) - 0usize];
    ["Offset of field: sockaddr::sa_family"][::std::mem::offset_of!(sockaddr, sa_family) - 1usize];
    ["Offset of field: sockaddr::sa_data"][::std::mem::offset_of!(sockaddr, sa_data) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sockaddr_header"][::std::mem::size_of::<__sockaddr_header>() - 2usize];
    ["Alignment of __sockaddr_header"][::std::mem::align_of::<__sockaddr_header>() - 1usize];
    ["Offset of field: __sockaddr_header::sa_len"]
        [::std::mem::offset_of!(__sockaddr_header, sa_len) - 0usize];
    ["Offset of field: __sockaddr_header::sa_family"]
        [::std::mem::offset_of!(__sockaddr_header, sa_family) - 1usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockproto"][::std::mem::size_of::<sockproto>() - 4usize];
    ["Alignment of sockproto"][::std::mem::align_of::<sockproto>() - 2usize];
    ["Offset of field: sockproto::sp_family"]
        [::std::mem::offset_of!(sockproto, sp_family) - 0usize];
    ["Offset of field: sockproto::sp_protocol"]
        [::std::mem::offset_of!(sockproto, sp_protocol) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::ffi::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::ffi::c_char; 112usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_storage"][::std::mem::size_of::<sockaddr_storage>() - 128usize];
    ["Alignment of sockaddr_storage"][::std::mem::align_of::<sockaddr_storage>() - 8usize];
    ["Offset of field: sockaddr_storage::ss_len"]
        [::std::mem::offset_of!(sockaddr_storage, ss_len) - 0usize];
    ["Offset of field: sockaddr_storage::ss_family"]
        [::std::mem::offset_of!(sockaddr_storage, ss_family) - 1usize];
    ["Offset of field: sockaddr_storage::__ss_pad1"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_pad1) - 2usize];
    ["Offset of field: sockaddr_storage::__ss_align"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_align) - 8usize];
    ["Offset of field: sockaddr_storage::__ss_pad2"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_pad2) - 16usize];
};
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::ffi::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::ffi::c_int,
    pub msg_control: *mut ::std::ffi::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of msghdr"][::std::mem::size_of::<msghdr>() - 48usize];
    ["Alignment of msghdr"][::std::mem::align_of::<msghdr>() - 8usize];
    ["Offset of field: msghdr::msg_name"][::std::mem::offset_of!(msghdr, msg_name) - 0usize];
    ["Offset of field: msghdr::msg_namelen"][::std::mem::offset_of!(msghdr, msg_namelen) - 8usize];
    ["Offset of field: msghdr::msg_iov"][::std::mem::offset_of!(msghdr, msg_iov) - 16usize];
    ["Offset of field: msghdr::msg_iovlen"][::std::mem::offset_of!(msghdr, msg_iovlen) - 24usize];
    ["Offset of field: msghdr::msg_control"][::std::mem::offset_of!(msghdr, msg_control) - 32usize];
    ["Offset of field: msghdr::msg_controllen"]
        [::std::mem::offset_of!(msghdr, msg_controllen) - 40usize];
    ["Offset of field: msghdr::msg_flags"][::std::mem::offset_of!(msghdr, msg_flags) - 44usize];
};
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::ffi::c_int,
    pub cmsg_type: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cmsghdr"][::std::mem::size_of::<cmsghdr>() - 12usize];
    ["Alignment of cmsghdr"][::std::mem::align_of::<cmsghdr>() - 4usize];
    ["Offset of field: cmsghdr::cmsg_len"][::std::mem::offset_of!(cmsghdr, cmsg_len) - 0usize];
    ["Offset of field: cmsghdr::cmsg_level"][::std::mem::offset_of!(cmsghdr, cmsg_level) - 4usize];
    ["Offset of field: cmsghdr::cmsg_type"][::std::mem::offset_of!(cmsghdr, cmsg_type) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::ffi::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sf_hdtr"][::std::mem::size_of::<sf_hdtr>() - 32usize];
    ["Alignment of sf_hdtr"][::std::mem::align_of::<sf_hdtr>() - 8usize];
    ["Offset of field: sf_hdtr::headers"][::std::mem::offset_of!(sf_hdtr, headers) - 0usize];
    ["Offset of field: sf_hdtr::hdr_cnt"][::std::mem::offset_of!(sf_hdtr, hdr_cnt) - 8usize];
    ["Offset of field: sf_hdtr::trailers"][::std::mem::offset_of!(sf_hdtr, trailers) - 16usize];
    ["Offset of field: sf_hdtr::trl_cnt"][::std::mem::offset_of!(sf_hdtr, trl_cnt) - 24usize];
};
impl Default for sf_hdtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn accept(
        arg1: ::std::ffi::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn bind(
        arg1: ::std::ffi::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn connect(
        arg1: ::std::ffi::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn getpeername(
        arg1: ::std::ffi::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn getsockname(
        arg1: ::std::ffi::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn getsockopt(
        arg1: ::std::ffi::c_int,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn listen(arg1: ::std::ffi::c_int, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn recv(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_void,
        arg3: usize,
        arg4: ::std::ffi::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvfrom(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_void,
        arg3: usize,
        arg4: ::std::ffi::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvmsg(arg1: ::std::ffi::c_int, arg2: *mut msghdr, arg3: ::std::ffi::c_int) -> isize;
}
unsafe extern "C" {
    pub fn send(
        arg1: ::std::ffi::c_int,
        arg2: *const ::std::ffi::c_void,
        arg3: usize,
        arg4: ::std::ffi::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendmsg(arg1: ::std::ffi::c_int, arg2: *const msghdr, arg3: ::std::ffi::c_int) -> isize;
}
unsafe extern "C" {
    pub fn sendto(
        arg1: ::std::ffi::c_int,
        arg2: *const ::std::ffi::c_void,
        arg3: usize,
        arg4: ::std::ffi::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn setsockopt(
        arg1: ::std::ffi::c_int,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_void,
        arg5: socklen_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn shutdown(arg1: ::std::ffi::c_int, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn sockatmark(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn socket(
        arg1: ::std::ffi::c_int,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn socketpair(
        arg1: ::std::ffi::c_int,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn sendfile(
        arg1: ::std::ffi::c_int,
        arg2: ::std::ffi::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pfctlinput(arg1: ::std::ffi::c_int, arg2: *mut sockaddr);
}
unsafe extern "C" {
    pub fn connectx(
        arg1: ::std::ffi::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::ffi::c_uint,
        arg5: *const iovec,
        arg6: ::std::ffi::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn disconnectx(
        arg1: ::std::ffi::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::ffi::c_int;
}
pub type __darwin_nl_item = ::std::ffi::c_int;
pub type __darwin_wctrans_t = ::std::ffi::c_int;
pub type __darwin_wctype_t = __uint32_t;
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::ffi::c_void,
        __c: ::std::ffi::c_int,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::ffi::c_void,
        __s2: *const ::std::ffi::c_void,
        __n: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::ffi::c_void,
        __src: *const ::std::ffi::c_void,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dst: *mut ::std::ffi::c_void,
        __src: *const ::std::ffi::c_void,
        __len: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __b: *mut ::std::ffi::c_void,
        __c: ::std::ffi::c_int,
        __len: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        __s1: *mut ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::ffi::c_char,
        __c: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::ffi::c_char,
        __src: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::ffi::c_char,
        __charset: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::ffi::c_int) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::ffi::c_char) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        __s1: *mut ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::ffi::c_char,
        __src: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::ffi::c_char,
        __charset: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::ffi::c_char,
        __c: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::ffi::c_char,
        __charset: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        __big: *const ::std::ffi::c_char,
        __little: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __str: *mut ::std::ffi::c_char,
        __sep: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::ffi::c_char,
        __s2: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::ffi::c_char,
        __sep: *const ::std::ffi::c_char,
        __lasts: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::ffi::c_int,
        __strerrbuf: *mut ::std::ffi::c_char,
        __buflen: usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strdup(__s1: *const ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::ffi::c_void,
        __src: *const ::std::ffi::c_void,
        __c: ::std::ffi::c_int,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::ffi::c_char,
        __src: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::ffi::c_char,
        __src: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __s1: *const ::std::ffi::c_char,
        __n: ::std::ffi::c_ulong,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnlen(__s1: *const ::std::ffi::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::ffi::c_int) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn memset_s(
        __s: *mut ::std::ffi::c_void,
        __smax: rsize_t,
        __c: ::std::ffi::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn memmem(
        __big: *const ::std::ffi::c_void,
        __big_len: usize,
        __little: *const ::std::ffi::c_void,
        __little_len: usize,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::ffi::c_void,
        __pattern4: *const ::std::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::ffi::c_void,
        __pattern8: *const ::std::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::ffi::c_void,
        __pattern16: *const ::std::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn strcasestr(
        __big: *const ::std::ffi::c_char,
        __little: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::ffi::c_char,
        __c: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        __big: *const ::std::ffi::c_char,
        __little: *const ::std::ffi::c_char,
        __len: usize,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::ffi::c_char,
        __source: *const ::std::ffi::c_char,
        __size: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::ffi::c_char,
        __source: *const ::std::ffi::c_char,
        __size: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strmode(__mode: ::std::ffi::c_int, __bp: *mut ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::ffi::c_char,
        __delim: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn swab(arg1: *const ::std::ffi::c_void, arg2: *mut ::std::ffi::c_void, __len: isize);
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::ffi::c_void,
        __b2: *const ::std::ffi::c_void,
        __len: usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strsignal_r(
        __sig: ::std::ffi::c_int,
        __strsignalbuf: *mut ::std::ffi::c_char,
        __buflen: usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::std::ffi::c_void,
        arg2: *const ::std::ffi::c_void,
        __n: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const ::std::ffi::c_void,
        arg2: *mut ::std::ffi::c_void,
        __n: ::std::ffi::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::std::ffi::c_void, __n: ::std::ffi::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_ulong,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::std::ffi::c_long) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::std::ffi::c_longlong) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::std::ffi::c_long) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::std::ffi::c_longlong) -> ::std::ffi::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __math_errhandling() -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::ffi::c_long) -> f32;
}
unsafe extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::ffi::c_long) -> f64;
}
unsafe extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::ffi::c_long) -> f64;
}
unsafe extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn lrint(arg1: f64) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn round(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn lround(arg1: f64) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::ffi::c_long;
}
unsafe extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llrint(arg1: f64) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llround(arg1: f64) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::ffi::c_int) -> f64;
}
unsafe extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nanf(arg1: *const ::std::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn nan(arg1: *const ::std::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nanl(arg1: *const ::std::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
unsafe extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabsf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __hypotf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __sqrtf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __ceilf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __floorf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __rintf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __roundf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __truncf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __copysignf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __nextafterf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaxf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fminf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaf16(
        arg1: __BindgenFloat16,
        arg2: __BindgenFloat16,
        arg3: __BindgenFloat16,
    ) -> __BindgenFloat16;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __float2"][::std::mem::size_of::<__float2>() - 8usize];
    ["Alignment of __float2"][::std::mem::align_of::<__float2>() - 4usize];
    ["Offset of field: __float2::__sinval"][::std::mem::offset_of!(__float2, __sinval) - 0usize];
    ["Offset of field: __float2::__cosval"][::std::mem::offset_of!(__float2, __cosval) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __double2"][::std::mem::size_of::<__double2>() - 16usize];
    ["Alignment of __double2"][::std::mem::align_of::<__double2>() - 8usize];
    ["Offset of field: __double2::__sinval"][::std::mem::offset_of!(__double2, __sinval) - 0usize];
    ["Offset of field: __double2::__cosval"][::std::mem::offset_of!(__double2, __cosval) - 8usize];
};
unsafe extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::ffi::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::ffi::c_int,
    pub name: *mut ::std::ffi::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of exception"][::std::mem::size_of::<exception>() - 40usize];
    ["Alignment of exception"][::std::mem::align_of::<exception>() - 8usize];
    ["Offset of field: exception::type_"][::std::mem::offset_of!(exception, type_) - 0usize];
    ["Offset of field: exception::name"][::std::mem::offset_of!(exception, name) - 8usize];
    ["Offset of field: exception::arg1"][::std::mem::offset_of!(exception, arg1) - 16usize];
    ["Offset of field: exception::arg2"][::std::mem::offset_of!(exception, arg2) - 24usize];
    ["Offset of field: exception::retval"][::std::mem::offset_of!(exception, retval) - 32usize];
};
impl Default for exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::ffi::c_int,
    pub __opaque: [::std::ffi::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 8usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
    ["Offset of field: sched_param::__opaque"]
        [::std::mem::offset_of!(sched_param, __opaque) - 4usize];
};
unsafe extern "C" {
    pub fn sched_yield() -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::ffi::c_int,
    pub tm_min: ::std::ffi::c_int,
    pub tm_hour: ::std::ffi::c_int,
    pub tm_mday: ::std::ffi::c_int,
    pub tm_mon: ::std::ffi::c_int,
    pub tm_year: ::std::ffi::c_int,
    pub tm_wday: ::std::ffi::c_int,
    pub tm_yday: ::std::ffi::c_int,
    pub tm_isdst: ::std::ffi::c_int,
    pub tm_gmtoff: ::std::ffi::c_long,
    pub tm_zone: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::ffi::c_char; 0usize];
}
unsafe extern "C" {
    pub static mut getdate_err: ::std::ffi::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::ffi::c_long;
}
unsafe extern "C" {
    pub static mut daylight: ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
unsafe extern "C" {
    pub fn getdate(arg1: *const ::std::ffi::c_char) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        arg1: *mut ::std::ffi::c_char,
        __maxsize: usize,
        arg2: *const ::std::ffi::c_char,
        arg3: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
unsafe extern "C" {
    pub fn tzsetwall();
}
unsafe extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::ffi::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::ffi::c_uint;
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::std::ffi::c_uint;
pub type qos_class_t = ::std::ffi::c_uint;
unsafe extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
unsafe extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
unsafe extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
unsafe extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::ffi::c_int,
    ) -> pthread_override_t;
}
unsafe extern "C" {
    pub fn pthread_override_qos_class_end_np(__override: pthread_override_t) -> ::std::ffi::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
pub type sigset_t = __darwin_sigset_t;
unsafe extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::ffi::c_void,
        arg3: *mut usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(arg1: *mut pthread_attr_t, arg2: usize) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::ffi::c_void,
        arg3: usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(arg1: *mut pthread_attr_t, arg2: usize) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::ffi::c_void) -> *mut ::std::ffi::c_void,
        >,
        arg4: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::ffi::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::ffi::c_int,
        arg3: *mut sched_param,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn pthread_join(arg1: pthread_t, arg2: *mut *mut ::std::ffi::c_void) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::ffi::c_void)>,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::ffi::c_int,
        arg3: *const sched_param,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
unsafe extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::ffi::c_char,
        arg3: usize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_main_np() -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
unsafe extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
unsafe extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::ffi::c_void) -> *mut ::std::ffi::c_void,
        >,
        arg4: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield_np();
}
unsafe extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::ffi::c_int);
}
unsafe extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::ffi::c_int;
}
pub type pthread_jit_write_callback_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::ffi::c_void) -> ::std::ffi::c_int>;
unsafe extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
unsafe extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut usize) -> ::std::ffi::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::ffi::c_uint;
unsafe extern "C" {
    pub fn readv(arg1: ::std::ffi::c_int, arg2: *const iovec, arg3: ::std::ffi::c_int) -> isize;
}
unsafe extern "C" {
    pub fn writev(arg1: ::std::ffi::c_int, arg2: *const iovec, arg3: ::std::ffi::c_int) -> isize;
}
unsafe extern "C" {
    pub fn preadv(
        arg1: ::std::ffi::c_int,
        arg2: *const iovec,
        arg3: ::std::ffi::c_int,
        arg4: off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwritev(
        arg1: ::std::ffi::c_int,
        arg2: *const iovec,
        arg3: ::std::ffi::c_int,
        arg4: off_t,
    ) -> isize;
}
pub type wchar_t = ::std::ffi::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::ffi::c_long;
pub type uintmax_t = ::std::ffi::c_ulong;
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vtim_mono(pub f64);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vtim_real(pub f64);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vtim_dur(pub f64);
#[doc = " txt (vas.h needed for the macros)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct txt {
    pub b: *const ::std::ffi::c_char,
    pub e: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of txt"][::std::mem::size_of::<txt>() - 16usize];
    ["Alignment of txt"][::std::mem::align_of::<txt>() - 8usize];
    ["Offset of field: txt::b"][::std::mem::offset_of!(txt, b) - 0usize];
    ["Offset of field: txt::e"][::std::mem::offset_of!(txt, e) - 8usize];
};
impl Default for txt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stevedore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct suckaddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_conf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl_sub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc_seg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsmw_cluster {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wrk_vpi {
    _unused: [u8; 0],
}
pub type stream_close_t = *const stream_close;
#[doc = " VCL_STRANDS:\n\n An argc+argv type of data structure where n indicates the number of\n strings in the p array. Individual components of a strands may be null.\n\n A STRANDS allows you to work on a strings concatenation with the\n option to collect it into a single STRING, or if possible work\n directly on individual parts.\n\n The memory management is very strict: a VMOD function receiving a\n STRANDS argument should keep no reference after the function returns.\n Retention of a STRANDS further in the ongoing task is undefined\n behavior and may result in a panic or data corruption."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strands {
    pub magic: ::std::ffi::c_uint,
    pub n: ::std::ffi::c_int,
    pub p: *mut *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of strands"][::std::mem::size_of::<strands>() - 16usize];
    ["Alignment of strands"][::std::mem::align_of::<strands>() - 8usize];
    ["Offset of field: strands::magic"][::std::mem::offset_of!(strands, magic) - 0usize];
    ["Offset of field: strands::n"][::std::mem::offset_of!(strands, n) - 4usize];
    ["Offset of field: strands::p"][::std::mem::offset_of!(strands, p) - 8usize];
};
impl Default for strands {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static vrt_null_strands: *const strands;
}
#[doc = " VCL_BLOB:\n\n Opaque, immutable data (pointer + length), minimum lifetime is the\n VCL task.\n\n Type (optional) is owned by the creator of the blob. blob consumers\n may use it for checks, but should not assert on it.\n\n The data behind the blob pointer is assumed to be immutable for the\n blob's lifetime.\n\n - memory for shortlived blobs can be put on the tasks workspace\n\n - management of memory for longer lived blobs is up to the vmod\n   (in which case the blob will probably be embedded in an object or\n    referenced by other state with vcl lifetime)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_blob {
    pub magic: ::std::ffi::c_uint,
    pub type_: ::std::ffi::c_uint,
    pub len: usize,
    pub blob: *const ::std::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_blob"][::std::mem::size_of::<vrt_blob>() - 24usize];
    ["Alignment of vrt_blob"][::std::mem::align_of::<vrt_blob>() - 8usize];
    ["Offset of field: vrt_blob::magic"][::std::mem::offset_of!(vrt_blob, magic) - 0usize];
    ["Offset of field: vrt_blob::type_"][::std::mem::offset_of!(vrt_blob, type_) - 4usize];
    ["Offset of field: vrt_blob::len"][::std::mem::offset_of!(vrt_blob, len) - 8usize];
    ["Offset of field: vrt_blob::blob"][::std::mem::offset_of!(vrt_blob, blob) - 16usize];
};
impl Default for vrt_blob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static vrt_null_blob: *const vrt_blob;
}
#[doc = " This is the central definition of the mapping from VCL types to\n C-types.  The python scripts read these from here.\n (keep alphabetic order)"]
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_ACL(pub *const vrt_acl);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_BACKEND(pub *const director);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_BLOB(pub *const vrt_blob);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_BODY(pub *const ::std::ffi::c_void);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_BOOL(pub ::std::ffi::c_uint);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_BYTES(pub i64);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_DURATION(pub vtim_dur);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_ENUM(pub *const ::std::ffi::c_char);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_HEADER(pub *const gethdr_s);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_HTTP(pub *mut http);
pub type VCL_INSTANCE = ::std::ffi::c_void;
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_INT(pub i64);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_IP(pub *const suckaddr);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_PROBE(pub *const vrt_backend_probe);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_REAL(pub f64);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vre {
    _unused: [u8; 0],
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_REGEX(pub *const vre);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_STEVEDORE(pub *const stevedore);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_STRANDS(pub *const strands);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_STRING(pub *const ::std::ffi::c_char);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_SUB(pub *const vcl_sub);
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VCL_TIME(pub vtim_real);
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_VCL(pub *mut vcl);
pub type VCL_VOID = ::std::ffi::c_void;
#[doc = " This is the composite \"context\" argument for compiled VCL, VRT and\n VMOD functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_ctx {
    pub magic: ::std::ffi::c_uint,
    pub syntax: ::std::ffi::c_uint,
    pub vclver: ::std::ffi::c_uint,
    pub method: ::std::ffi::c_uint,
    pub vpi: *mut wrk_vpi,
    pub msg: *mut vsb,
    pub vsl: *mut vsl_log,
    pub vcl: VCL_VCL,
    pub ws: *mut ws,
    pub sp: *mut sess,
    pub req: *mut req,
    pub http_req: VCL_HTTP,
    pub http_req_top: VCL_HTTP,
    pub http_resp: VCL_HTTP,
    pub bo: *mut busyobj,
    pub http_bereq: VCL_HTTP,
    pub http_beresp: VCL_HTTP,
    pub now: vtim_real,
    pub specific: *mut ::std::ffi::c_void,
    pub called: *mut ::std::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_ctx"][::std::mem::size_of::<vrt_ctx>() - 144usize];
    ["Alignment of vrt_ctx"][::std::mem::align_of::<vrt_ctx>() - 8usize];
    ["Offset of field: vrt_ctx::magic"][::std::mem::offset_of!(vrt_ctx, magic) - 0usize];
    ["Offset of field: vrt_ctx::syntax"][::std::mem::offset_of!(vrt_ctx, syntax) - 4usize];
    ["Offset of field: vrt_ctx::vclver"][::std::mem::offset_of!(vrt_ctx, vclver) - 8usize];
    ["Offset of field: vrt_ctx::method"][::std::mem::offset_of!(vrt_ctx, method) - 12usize];
    ["Offset of field: vrt_ctx::vpi"][::std::mem::offset_of!(vrt_ctx, vpi) - 16usize];
    ["Offset of field: vrt_ctx::msg"][::std::mem::offset_of!(vrt_ctx, msg) - 24usize];
    ["Offset of field: vrt_ctx::vsl"][::std::mem::offset_of!(vrt_ctx, vsl) - 32usize];
    ["Offset of field: vrt_ctx::vcl"][::std::mem::offset_of!(vrt_ctx, vcl) - 40usize];
    ["Offset of field: vrt_ctx::ws"][::std::mem::offset_of!(vrt_ctx, ws) - 48usize];
    ["Offset of field: vrt_ctx::sp"][::std::mem::offset_of!(vrt_ctx, sp) - 56usize];
    ["Offset of field: vrt_ctx::req"][::std::mem::offset_of!(vrt_ctx, req) - 64usize];
    ["Offset of field: vrt_ctx::http_req"][::std::mem::offset_of!(vrt_ctx, http_req) - 72usize];
    ["Offset of field: vrt_ctx::http_req_top"]
        [::std::mem::offset_of!(vrt_ctx, http_req_top) - 80usize];
    ["Offset of field: vrt_ctx::http_resp"][::std::mem::offset_of!(vrt_ctx, http_resp) - 88usize];
    ["Offset of field: vrt_ctx::bo"][::std::mem::offset_of!(vrt_ctx, bo) - 96usize];
    ["Offset of field: vrt_ctx::http_bereq"]
        [::std::mem::offset_of!(vrt_ctx, http_bereq) - 104usize];
    ["Offset of field: vrt_ctx::http_beresp"]
        [::std::mem::offset_of!(vrt_ctx, http_beresp) - 112usize];
    ["Offset of field: vrt_ctx::now"][::std::mem::offset_of!(vrt_ctx, now) - 120usize];
    ["Offset of field: vrt_ctx::specific"][::std::mem::offset_of!(vrt_ctx, specific) - 128usize];
    ["Offset of field: vrt_ctx::called"][::std::mem::offset_of!(vrt_ctx, called) - 136usize];
};
impl Default for vrt_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_CTX_Assert(ctx: *const vrt_ctx);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VclFuncCall {
    Static = 0,
    Dynamic = 1,
    Check = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VclFuncFail {
    Ok = 0,
    Recurse = 1,
    Method = 2,
}
pub type vcl_func_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VclFuncCall, arg2: *mut VclFuncFail),
>;
#[doc = " This is the interface structure to a compiled VMOD\n (produced by vmodtool.py)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_data {
    pub vrt_major: ::std::ffi::c_uint,
    pub vrt_minor: ::std::ffi::c_uint,
    pub file_id: *const ::std::ffi::c_char,
    pub name: *const ::std::ffi::c_char,
    pub func_name: *const ::std::ffi::c_char,
    pub func: *const ::std::ffi::c_void,
    pub func_len: ::std::ffi::c_int,
    pub proto: *const ::std::ffi::c_char,
    pub json: *const ::std::ffi::c_char,
    pub abi: *const ::std::ffi::c_char,
    pub vcs: *const ::std::ffi::c_char,
    pub version: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vmod_data"][::std::mem::size_of::<vmod_data>() - 88usize];
    ["Alignment of vmod_data"][::std::mem::align_of::<vmod_data>() - 8usize];
    ["Offset of field: vmod_data::vrt_major"]
        [::std::mem::offset_of!(vmod_data, vrt_major) - 0usize];
    ["Offset of field: vmod_data::vrt_minor"]
        [::std::mem::offset_of!(vmod_data, vrt_minor) - 4usize];
    ["Offset of field: vmod_data::file_id"][::std::mem::offset_of!(vmod_data, file_id) - 8usize];
    ["Offset of field: vmod_data::name"][::std::mem::offset_of!(vmod_data, name) - 16usize];
    ["Offset of field: vmod_data::func_name"]
        [::std::mem::offset_of!(vmod_data, func_name) - 24usize];
    ["Offset of field: vmod_data::func"][::std::mem::offset_of!(vmod_data, func) - 32usize];
    ["Offset of field: vmod_data::func_len"][::std::mem::offset_of!(vmod_data, func_len) - 40usize];
    ["Offset of field: vmod_data::proto"][::std::mem::offset_of!(vmod_data, proto) - 48usize];
    ["Offset of field: vmod_data::json"][::std::mem::offset_of!(vmod_data, json) - 56usize];
    ["Offset of field: vmod_data::abi"][::std::mem::offset_of!(vmod_data, abi) - 64usize];
    ["Offset of field: vmod_data::vcs"][::std::mem::offset_of!(vmod_data, vcs) - 72usize];
    ["Offset of field: vmod_data::version"][::std::mem::offset_of!(vmod_data, version) - 80usize];
};
impl Default for vmod_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Events sent to VMODs and directors:\n - VCL: VCL temperature events\n - VDI: director events"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VclEvent {
    Load = 0,
    Warm = 1,
    Cold = 2,
    Discard = 3,
    Sick = 4,
}
pub type vmod_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vmod_priv,
        arg2: VclEvent,
    ) -> ::std::ffi::c_int,
>;
unsafe extern "C" {
    #[doc = " Utility functions operating on VCL_types\n (alphabetic by type-ish)"]
    pub fn VRT_acl_match(ctx: *const vrt_ctx, arg1: VCL_ACL, arg2: VCL_IP) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_DirectorResolve(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND;
}
unsafe extern "C" {
    pub fn VRT_blob(
        ctx: *const vrt_ctx,
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_void,
        arg3: usize,
        arg4: ::std::ffi::c_uint,
    ) -> VCL_BLOB;
}
unsafe extern "C" {
    pub fn VRT_INT_is_valid(arg1: VCL_INT) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_VSA_GetPtr(
        ctx: *const vrt_ctx,
        sua: VCL_IP,
        dst: *mut *const ::std::ffi::c_uchar,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_ipcmp(ctx: *const vrt_ctx, arg1: VCL_IP, arg2: VCL_IP) -> VCL_BOOL;
}
unsafe extern "C" {
    pub fn VRT_Format_Proxy(
        arg1: *mut vsb,
        arg2: VCL_INT,
        arg3: VCL_IP,
        arg4: VCL_IP,
        arg5: VCL_STRING,
    );
}
unsafe extern "C" {
    pub fn VRT_REAL_is_valid(arg1: VCL_REAL) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_re_match(ctx: *const vrt_ctx, arg1: VCL_STRING, arg2: VCL_REGEX) -> VCL_BOOL;
}
unsafe extern "C" {
    pub fn VRT_regsub(
        ctx: *const vrt_ctx,
        all: ::std::ffi::c_int,
        arg1: VCL_STRING,
        arg2: VCL_REGEX,
        arg3: VCL_STRING,
    ) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_stevedore(nm: *const ::std::ffi::c_char) -> VCL_STEVEDORE;
}
unsafe extern "C" {
    pub fn VRT_AllocStrandsWS(arg1: *mut ws, arg2: ::std::ffi::c_int) -> *mut strands;
}
unsafe extern "C" {
    pub fn VRT_CompareStrands(a: VCL_STRANDS, b: VCL_STRANDS) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_Strands2Bool(arg1: VCL_STRANDS) -> VCL_BOOL;
}
unsafe extern "C" {
    pub fn VRT_HashStrands32(arg1: VCL_STRANDS) -> u32;
}
unsafe extern "C" {
    pub fn VRT_Strands(
        arg1: *mut ::std::ffi::c_char,
        arg2: usize,
        arg3: VCL_STRANDS,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn VRT_StrandsWS(
        arg1: *mut ws,
        arg2: *const ::std::ffi::c_char,
        arg3: VCL_STRANDS,
    ) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_UpperLowerStrands(
        ctx: *const vrt_ctx,
        s: VCL_STRANDS,
        up: ::std::ffi::c_int,
    ) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_check_call(ctx: *const vrt_ctx, arg1: VCL_SUB) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_call(ctx: *const vrt_ctx, arg1: VCL_SUB);
}
unsafe extern "C" {
    pub fn VRT_BACKEND_string(arg1: VCL_BACKEND) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_BOOL_string(arg1: VCL_BOOL) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_BLOB_string(ctx: *const vrt_ctx, arg1: VCL_BLOB) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_INT_string(ctx: *const vrt_ctx, arg1: VCL_INT) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_IP_string(ctx: *const vrt_ctx, arg1: VCL_IP) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_REAL_string(ctx: *const vrt_ctx, arg1: VCL_REAL) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_STEVEDORE_string(arg1: VCL_STEVEDORE) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_STRANDS_string(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_TIME_string(ctx: *const vrt_ctx, arg1: VCL_TIME) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_strcmp(
        s1: *const ::std::ffi::c_char,
        s2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VRT_memmove(
        dst: *mut ::std::ffi::c_void,
        src: *const ::std::ffi::c_void,
        len: ::std::ffi::c_uint,
    );
}
#[doc = " We want the VCC to spit this structs out as const, but when VMODs\n come up with them we want to clone them into malloc'ed space which\n we can free again.\n We collect all the knowledge here by macroizing the fields and make\n a macro for handling them all.\n See also:  cache_backend.h & cache_backend_cfg.c\n One of those things..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_endpoint {
    pub magic: ::std::ffi::c_uint,
    pub ipv4: VCL_IP,
    pub ipv6: VCL_IP,
    pub uds_path: *const ::std::ffi::c_char,
    pub preamble: *const vrt_blob,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_endpoint"][::std::mem::size_of::<vrt_endpoint>() - 40usize];
    ["Alignment of vrt_endpoint"][::std::mem::align_of::<vrt_endpoint>() - 8usize];
    ["Offset of field: vrt_endpoint::magic"][::std::mem::offset_of!(vrt_endpoint, magic) - 0usize];
    ["Offset of field: vrt_endpoint::ipv4"][::std::mem::offset_of!(vrt_endpoint, ipv4) - 8usize];
    ["Offset of field: vrt_endpoint::ipv6"][::std::mem::offset_of!(vrt_endpoint, ipv6) - 16usize];
    ["Offset of field: vrt_endpoint::uds_path"]
        [::std::mem::offset_of!(vrt_endpoint, uds_path) - 24usize];
    ["Offset of field: vrt_endpoint::preamble"]
        [::std::mem::offset_of!(vrt_endpoint, preamble) - 32usize];
};
impl Default for vrt_endpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend {
    pub magic: ::std::ffi::c_uint,
    pub endpoint: *const vrt_endpoint,
    pub vcl_name: *const ::std::ffi::c_char,
    pub hosthdr: *const ::std::ffi::c_char,
    pub authority: *const ::std::ffi::c_char,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub backend_wait_timeout: vtim_dur,
    pub max_connections: ::std::ffi::c_uint,
    pub proxy_header: ::std::ffi::c_uint,
    pub backend_wait_limit: ::std::ffi::c_uint,
    pub probe: VCL_PROBE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_backend"][::std::mem::size_of::<vrt_backend>() - 96usize];
    ["Alignment of vrt_backend"][::std::mem::align_of::<vrt_backend>() - 8usize];
    ["Offset of field: vrt_backend::magic"][::std::mem::offset_of!(vrt_backend, magic) - 0usize];
    ["Offset of field: vrt_backend::endpoint"]
        [::std::mem::offset_of!(vrt_backend, endpoint) - 8usize];
    ["Offset of field: vrt_backend::vcl_name"]
        [::std::mem::offset_of!(vrt_backend, vcl_name) - 16usize];
    ["Offset of field: vrt_backend::hosthdr"]
        [::std::mem::offset_of!(vrt_backend, hosthdr) - 24usize];
    ["Offset of field: vrt_backend::authority"]
        [::std::mem::offset_of!(vrt_backend, authority) - 32usize];
    ["Offset of field: vrt_backend::connect_timeout"]
        [::std::mem::offset_of!(vrt_backend, connect_timeout) - 40usize];
    ["Offset of field: vrt_backend::first_byte_timeout"]
        [::std::mem::offset_of!(vrt_backend, first_byte_timeout) - 48usize];
    ["Offset of field: vrt_backend::between_bytes_timeout"]
        [::std::mem::offset_of!(vrt_backend, between_bytes_timeout) - 56usize];
    ["Offset of field: vrt_backend::backend_wait_timeout"]
        [::std::mem::offset_of!(vrt_backend, backend_wait_timeout) - 64usize];
    ["Offset of field: vrt_backend::max_connections"]
        [::std::mem::offset_of!(vrt_backend, max_connections) - 72usize];
    ["Offset of field: vrt_backend::proxy_header"]
        [::std::mem::offset_of!(vrt_backend, proxy_header) - 76usize];
    ["Offset of field: vrt_backend::backend_wait_limit"]
        [::std::mem::offset_of!(vrt_backend, backend_wait_limit) - 80usize];
    ["Offset of field: vrt_backend::probe"][::std::mem::offset_of!(vrt_backend, probe) - 88usize];
};
impl Default for vrt_backend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend_probe {
    pub magic: ::std::ffi::c_uint,
    pub url: *const ::std::ffi::c_char,
    pub request: *const ::std::ffi::c_char,
    pub timeout: vtim_dur,
    pub interval: vtim_dur,
    pub exp_status: ::std::ffi::c_uint,
    pub window: ::std::ffi::c_uint,
    pub threshold: ::std::ffi::c_uint,
    pub initial: ::std::ffi::c_uint,
    pub exp_close: ::std::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_backend_probe"][::std::mem::size_of::<vrt_backend_probe>() - 64usize];
    ["Alignment of vrt_backend_probe"][::std::mem::align_of::<vrt_backend_probe>() - 8usize];
    ["Offset of field: vrt_backend_probe::magic"]
        [::std::mem::offset_of!(vrt_backend_probe, magic) - 0usize];
    ["Offset of field: vrt_backend_probe::url"]
        [::std::mem::offset_of!(vrt_backend_probe, url) - 8usize];
    ["Offset of field: vrt_backend_probe::request"]
        [::std::mem::offset_of!(vrt_backend_probe, request) - 16usize];
    ["Offset of field: vrt_backend_probe::timeout"]
        [::std::mem::offset_of!(vrt_backend_probe, timeout) - 24usize];
    ["Offset of field: vrt_backend_probe::interval"]
        [::std::mem::offset_of!(vrt_backend_probe, interval) - 32usize];
    ["Offset of field: vrt_backend_probe::exp_status"]
        [::std::mem::offset_of!(vrt_backend_probe, exp_status) - 40usize];
    ["Offset of field: vrt_backend_probe::window"]
        [::std::mem::offset_of!(vrt_backend_probe, window) - 44usize];
    ["Offset of field: vrt_backend_probe::threshold"]
        [::std::mem::offset_of!(vrt_backend_probe, threshold) - 48usize];
    ["Offset of field: vrt_backend_probe::initial"]
        [::std::mem::offset_of!(vrt_backend_probe, initial) - 52usize];
    ["Offset of field: vrt_backend_probe::exp_close"]
        [::std::mem::offset_of!(vrt_backend_probe, exp_close) - 56usize];
};
impl Default for vrt_backend_probe {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_new_backend(
        ctx: *const vrt_ctx,
        arg1: *const vrt_backend,
        arg2: VCL_BACKEND,
    ) -> VCL_BACKEND;
}
unsafe extern "C" {
    pub fn VRT_new_backend_clustered(
        ctx: *const vrt_ctx,
        arg1: *mut vsmw_cluster,
        arg2: *const vrt_backend,
        arg3: VCL_BACKEND,
    ) -> VCL_BACKEND;
}
unsafe extern "C" {
    pub fn VRT_backend_vsm_need(ctx: *const vrt_ctx) -> usize;
}
unsafe extern "C" {
    pub fn VRT_delete_backend(ctx: *const vrt_ctx, arg1: *mut VCL_BACKEND);
}
unsafe extern "C" {
    pub fn VRT_Endpoint_Clone(vep: *const vrt_endpoint) -> *mut vrt_endpoint;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Getting hold of the various struct http"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetHeader {
    Req = 0,
    ReqTop = 1,
    Resp = 2,
    Obj = 3,
    Bereq = 4,
    Beresp = 5,
    ObjStale = 6,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _bindgen_ty_2 {
    pub len: ::std::ffi::c_uchar,
    pub str_: __IncompleteArrayField<::std::ffi::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _bindgen_ty_2"][::std::mem::size_of::<_bindgen_ty_2>() - 1usize];
    ["Alignment of _bindgen_ty_2"][::std::mem::align_of::<_bindgen_ty_2>() - 1usize];
    ["Offset of field: _bindgen_ty_2::len"][::std::mem::offset_of!(_bindgen_ty_2, len) - 0usize];
    ["Offset of field: _bindgen_ty_2::str_"][::std::mem::offset_of!(_bindgen_ty_2, str_) - 1usize];
};
pub type hdr_t = *const _bindgen_ty_2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gethdr_s {
    pub where_: GetHeader,
    pub what: hdr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gethdr_s"][::std::mem::size_of::<gethdr_s>() - 16usize];
    ["Alignment of gethdr_s"][::std::mem::align_of::<gethdr_s>() - 8usize];
    ["Offset of field: gethdr_s::where_"][::std::mem::offset_of!(gethdr_s, where_) - 0usize];
    ["Offset of field: gethdr_s::what"][::std::mem::offset_of!(gethdr_s, what) - 8usize];
};
impl Default for gethdr_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_selecthttp(ctx: *const vrt_ctx, arg1: GetHeader) -> VCL_HTTP;
}
unsafe extern "C" {
    pub fn VRT_GetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER) -> VCL_STRING;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " req related"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Body {
    SetString = 0,
    AddString = 1,
    SetBlob = 2,
    AddBlob = 3,
}
unsafe extern "C" {
    pub fn VRT_CacheReqBody(ctx: *const vrt_ctx, maxsize: VCL_BYTES) -> VCL_BYTES;
}
unsafe extern "C" {
    pub fn VRT_ban_string(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_STRING;
}
unsafe extern "C" {
    pub fn VRT_purge(
        ctx: *const vrt_ctx,
        arg1: VCL_DURATION,
        arg2: VCL_DURATION,
        arg3: VCL_DURATION,
    ) -> VCL_INT;
}
unsafe extern "C" {
    pub fn VRT_synth(ctx: *const vrt_ctx, arg1: VCL_INT, arg2: VCL_STRING);
}
unsafe extern "C" {
    pub fn VRT_hit_for_pass(ctx: *const vrt_ctx, arg1: VCL_DURATION);
}
unsafe extern "C" {
    pub fn VRT_ValidHdr(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_BOOL;
}
unsafe extern "C" {
    pub fn VRT_UnsetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER);
}
unsafe extern "C" {
    pub fn VRT_SetHdr(
        ctx: *const vrt_ctx,
        arg1: VCL_HEADER,
        pfx: *const ::std::ffi::c_char,
        arg2: VCL_STRANDS,
    );
}
unsafe extern "C" {
    pub fn VRT_handling(ctx: *const vrt_ctx, hand: ::std::ffi::c_uint);
}
unsafe extern "C" {
    pub fn VRT_handled(ctx: *const vrt_ctx) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn VRT_trace(ctx: *const vrt_ctx, arg1: VCL_BOOL);
}
unsafe extern "C" {
    pub fn VRT_fail(ctx: *const vrt_ctx, fmt: *const ::std::ffi::c_char, ...);
}
unsafe extern "C" {
    pub fn VRT_hashdata(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
unsafe extern "C" {
    pub fn VRT_Rollback(ctx: *const vrt_ctx, arg1: VCL_HTTP);
}
unsafe extern "C" {
    pub fn VRT_synth_strands(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
unsafe extern "C" {
    pub fn VRT_synth_blob(ctx: *const vrt_ctx, arg1: VCL_BLOB);
}
#[doc = " VDI - Director API"]
pub type vdi_healthy_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL,
>;
pub type vdi_resolve_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND,
>;
pub type vdi_gethdrs_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> ::std::ffi::c_int,
>;
pub type vdi_getip_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_IP>;
pub type vdi_finish_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND)>;
pub type vdi_http1pipe_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> stream_close_t,
>;
pub type vdi_event_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: VclEvent)>;
pub type vdi_release_f = ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND)>;
pub type vdi_destroy_f = ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND)>;
pub type vdi_panic_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: *mut vsb)>;
pub type vdi_list_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: VCL_BACKEND,
        arg2: *mut vsb,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdi_methods {
    pub magic: ::std::ffi::c_uint,
    pub type_: *const ::std::ffi::c_char,
    pub http1pipe: vdi_http1pipe_f,
    pub healthy: vdi_healthy_f,
    pub resolve: vdi_resolve_f,
    pub gethdrs: vdi_gethdrs_f,
    pub getip: vdi_getip_f,
    pub finish: vdi_finish_f,
    pub event: vdi_event_f,
    pub release: vdi_release_f,
    pub destroy: vdi_destroy_f,
    pub panic: vdi_panic_f,
    pub list: vdi_list_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdi_methods"][::std::mem::size_of::<vdi_methods>() - 104usize];
    ["Alignment of vdi_methods"][::std::mem::align_of::<vdi_methods>() - 8usize];
    ["Offset of field: vdi_methods::magic"][::std::mem::offset_of!(vdi_methods, magic) - 0usize];
    ["Offset of field: vdi_methods::type_"][::std::mem::offset_of!(vdi_methods, type_) - 8usize];
    ["Offset of field: vdi_methods::http1pipe"]
        [::std::mem::offset_of!(vdi_methods, http1pipe) - 16usize];
    ["Offset of field: vdi_methods::healthy"]
        [::std::mem::offset_of!(vdi_methods, healthy) - 24usize];
    ["Offset of field: vdi_methods::resolve"]
        [::std::mem::offset_of!(vdi_methods, resolve) - 32usize];
    ["Offset of field: vdi_methods::gethdrs"]
        [::std::mem::offset_of!(vdi_methods, gethdrs) - 40usize];
    ["Offset of field: vdi_methods::getip"][::std::mem::offset_of!(vdi_methods, getip) - 48usize];
    ["Offset of field: vdi_methods::finish"][::std::mem::offset_of!(vdi_methods, finish) - 56usize];
    ["Offset of field: vdi_methods::event"][::std::mem::offset_of!(vdi_methods, event) - 64usize];
    ["Offset of field: vdi_methods::release"]
        [::std::mem::offset_of!(vdi_methods, release) - 72usize];
    ["Offset of field: vdi_methods::destroy"]
        [::std::mem::offset_of!(vdi_methods, destroy) - 80usize];
    ["Offset of field: vdi_methods::panic"][::std::mem::offset_of!(vdi_methods, panic) - 88usize];
    ["Offset of field: vdi_methods::list"][::std::mem::offset_of!(vdi_methods, list) - 96usize];
};
impl Default for vdi_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct director {
    pub magic: ::std::ffi::c_uint,
    pub priv_: *mut ::std::ffi::c_void,
    pub vcl_name: *mut ::std::ffi::c_char,
    pub vdir: *mut vcldir,
    pub mtx: *mut lock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of director"][::std::mem::size_of::<director>() - 40usize];
    ["Alignment of director"][::std::mem::align_of::<director>() - 8usize];
    ["Offset of field: director::magic"][::std::mem::offset_of!(director, magic) - 0usize];
    ["Offset of field: director::priv_"][::std::mem::offset_of!(director, priv_) - 8usize];
    ["Offset of field: director::vcl_name"][::std::mem::offset_of!(director, vcl_name) - 16usize];
    ["Offset of field: director::vdir"][::std::mem::offset_of!(director, vdir) - 24usize];
    ["Offset of field: director::mtx"][::std::mem::offset_of!(director, mtx) - 32usize];
};
impl Default for director {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_Healthy(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL;
}
unsafe extern "C" {
    pub fn VRT_SetChanged(arg1: VCL_BACKEND, arg2: VCL_TIME);
}
unsafe extern "C" {
    pub fn VRT_AddDirector(
        ctx: *const vrt_ctx,
        arg1: *const vdi_methods,
        arg2: *mut ::std::ffi::c_void,
        arg3: *const ::std::ffi::c_char,
        ...
    ) -> VCL_BACKEND;
}
unsafe extern "C" {
    pub fn VRT_DisableDirector(arg1: VCL_BACKEND);
}
unsafe extern "C" {
    pub fn VRT_StaticDirector(arg1: VCL_BACKEND);
}
unsafe extern "C" {
    pub fn VRT_LookupDirector(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_BACKEND;
}
unsafe extern "C" {
    pub fn VRT_DelDirector(arg1: *mut VCL_BACKEND);
}
unsafe extern "C" {
    pub fn VRT_Assign_Backend(dst: *mut VCL_BACKEND, src: VCL_BACKEND);
}
#[doc = " vmod_priv related"]
pub type vmod_priv_fini_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: *mut ::std::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv_methods {
    pub magic: ::std::ffi::c_uint,
    pub type_: *const ::std::ffi::c_char,
    pub fini: vmod_priv_fini_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vmod_priv_methods"][::std::mem::size_of::<vmod_priv_methods>() - 24usize];
    ["Alignment of vmod_priv_methods"][::std::mem::align_of::<vmod_priv_methods>() - 8usize];
    ["Offset of field: vmod_priv_methods::magic"]
        [::std::mem::offset_of!(vmod_priv_methods, magic) - 0usize];
    ["Offset of field: vmod_priv_methods::type_"]
        [::std::mem::offset_of!(vmod_priv_methods, type_) - 8usize];
    ["Offset of field: vmod_priv_methods::fini"]
        [::std::mem::offset_of!(vmod_priv_methods, fini) - 16usize];
};
impl Default for vmod_priv_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv {
    pub priv_: *mut ::std::ffi::c_void,
    pub len: ::std::ffi::c_long,
    pub methods: *const vmod_priv_methods,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vmod_priv"][::std::mem::size_of::<vmod_priv>() - 24usize];
    ["Alignment of vmod_priv"][::std::mem::align_of::<vmod_priv>() - 8usize];
    ["Offset of field: vmod_priv::priv_"][::std::mem::offset_of!(vmod_priv, priv_) - 0usize];
    ["Offset of field: vmod_priv::len"][::std::mem::offset_of!(vmod_priv, len) - 8usize];
    ["Offset of field: vmod_priv::methods"][::std::mem::offset_of!(vmod_priv, methods) - 16usize];
};
impl Default for vmod_priv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_priv_fini(ctx: *const vrt_ctx, p: *const vmod_priv);
}
unsafe extern "C" {
    pub fn VRT_priv_task(ctx: *const vrt_ctx, vmod_id: *const ::std::ffi::c_void)
    -> *mut vmod_priv;
}
unsafe extern "C" {
    pub fn VRT_priv_task_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::ffi::c_void,
    ) -> *mut vmod_priv;
}
unsafe extern "C" {
    pub fn VRT_priv_top(ctx: *const vrt_ctx, vmod_id: *const ::std::ffi::c_void) -> *mut vmod_priv;
}
unsafe extern "C" {
    pub fn VRT_priv_top_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::ffi::c_void,
    ) -> *mut vmod_priv;
}
unsafe extern "C" {
    #[doc = " VSM and VSC"]
    pub fn VRT_VSM_Cluster_New(ctx: *const vrt_ctx, arg1: usize) -> *mut vsmw_cluster;
}
unsafe extern "C" {
    pub fn VRT_VSM_Cluster_Destroy(ctx: *const vrt_ctx, arg1: *mut *mut vsmw_cluster);
}
unsafe extern "C" {
    pub fn VRT_VSC_Allocv(
        arg1: *mut vsmw_cluster,
        arg2: *mut *mut vsc_seg,
        arg3: *const ::std::ffi::c_char,
        arg4: usize,
        arg5: *const ::std::ffi::c_uchar,
        arg6: usize,
        arg7: *const ::std::ffi::c_char,
        arg8: va_list,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn VRT_VSC_Alloc(
        arg1: *mut vsmw_cluster,
        arg2: *mut *mut vsc_seg,
        arg3: *const ::std::ffi::c_char,
        arg4: usize,
        arg5: *const ::std::ffi::c_uchar,
        arg6: usize,
        arg7: *const ::std::ffi::c_char,
        ...
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn VRT_VSC_Destroy(arg1: *const ::std::ffi::c_char, arg2: *mut vsc_seg);
}
unsafe extern "C" {
    pub fn VRT_VSC_Hide(arg1: *const vsc_seg);
}
unsafe extern "C" {
    pub fn VRT_VSC_Reveal(arg1: *const vsc_seg);
}
unsafe extern "C" {
    pub fn VRT_VSC_Overhead(arg1: usize) -> usize;
}
#[doc = " API to restrict the VCL in various ways"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vclref {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn VRT_VCL_Prevent_Cold(
        ctx: *const vrt_ctx,
        arg1: *const ::std::ffi::c_char,
    ) -> *mut vclref;
}
unsafe extern "C" {
    pub fn VRT_VCL_Allow_Cold(arg1: *mut *mut vclref);
}
unsafe extern "C" {
    pub fn VRT_VCL_Prevent_Discard(
        ctx: *const vrt_ctx,
        arg1: *const ::std::ffi::c_char,
    ) -> *mut vclref;
}
unsafe extern "C" {
    pub fn VRT_VCL_Allow_Discard(arg1: *mut *mut vclref);
}
unsafe extern "C" {
    #[doc = " Deprecated interfaces, do not use, they will disappear at some point."]
    pub fn VRT_synth_page(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
unsafe extern "C" {
    pub fn VRT_Stv(nm: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn __error() -> *mut ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VAS_errtxt(e: ::std::ffi::c_int) -> *const ::std::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Vas {
    Wrong = 0,
    Missing = 1,
    Assert = 2,
    Incomplete = 3,
    Vcl = 4,
}
pub type vas_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_char,
        arg5: Vas,
    ),
>;
unsafe extern "C" {
    pub static mut VAS_Fail_Func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::ffi::c_char,
            arg2: *const ::std::ffi::c_char,
            arg3: ::std::ffi::c_int,
            arg4: *const ::std::ffi::c_char,
            arg5: Vas,
        ) -> !,
    >;
}
unsafe extern "C" {
    pub fn VAS_Fail(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_char,
        arg5: Vas,
    ) -> !;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VslTag {
    Bogus = 0,
    Debug = 1,
    Error = 2,
    Cli = 3,
    SessOpen = 4,
    SessClose = 5,
    BackendOpen = 6,
    BackendClose = 7,
    HttpGarbage = 8,
    Proxy = 9,
    ProxyGarbage = 10,
    Length = 11,
    FetchError = 12,
    ReqMethod = 13,
    ReqUrl = 14,
    ReqProtocol = 15,
    ReqStatus = 16,
    ReqReason = 17,
    ReqHeader = 18,
    ReqUnset = 19,
    ReqLost = 20,
    RespMethod = 21,
    RespUrl = 22,
    RespProtocol = 23,
    RespStatus = 24,
    RespReason = 25,
    RespHeader = 26,
    RespUnset = 27,
    RespLost = 28,
    BereqMethod = 29,
    BereqUrl = 30,
    BereqProtocol = 31,
    BereqStatus = 32,
    BereqReason = 33,
    BereqHeader = 34,
    BereqUnset = 35,
    BereqLost = 36,
    BerespMethod = 37,
    BerespUrl = 38,
    BerespProtocol = 39,
    BerespStatus = 40,
    BerespReason = 41,
    BerespHeader = 42,
    BerespUnset = 43,
    BerespLost = 44,
    ObjMethod = 45,
    ObjUrl = 46,
    ObjProtocol = 47,
    ObjStatus = 48,
    ObjReason = 49,
    ObjHeader = 50,
    ObjUnset = 51,
    ObjLost = 52,
    BogoHeader = 53,
    LostHeader = 54,
    Ttl = 55,
    FetchBody = 56,
    VclAcl = 57,
    VclCall = 58,
    VclTrace = 59,
    VclReturn = 60,
    ReqStart = 61,
    Hit = 62,
    HitPass = 63,
    ExpBan = 64,
    ExpKill = 65,
    WorkThread = 66,
    EsiXmlerror = 67,
    Hash = 68,
    BackendHealth = 69,
    VclLog = 70,
    VclError = 71,
    Gzip = 72,
    Link = 73,
    Begin = 74,
    End = 75,
    Vsl = 76,
    Storage = 77,
    Timestamp = 78,
    ReqAcct = 79,
    PipeAcct = 80,
    BereqAcct = 81,
    VfpAcct = 82,
    Witness = 83,
    H2RxHdr = 84,
    H2RxBody = 85,
    H2TxHdr = 86,
    H2TxBody = 87,
    HitMiss = 88,
    Filters = 89,
    SessError = 90,
    VclUse = 91,
    Notice = 92,
    VdpAcct = 93,
    Reserved = 254,
    Batch = 255,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vxids {
    pub vxid: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vxids"][::std::mem::size_of::<vxids>() - 8usize];
    ["Alignment of vxids"][::std::mem::align_of::<vxids>() - 8usize];
    ["Offset of field: vxids::vxid"][::std::mem::offset_of!(vxids, vxid) - 0usize];
};
pub type vxid_t = vxids;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct body_status {
    pub name: *const ::std::ffi::c_char,
    pub nbr: ::std::ffi::c_int,
    pub avail: ::std::ffi::c_int,
    pub length_known: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of body_status"][::std::mem::size_of::<body_status>() - 24usize];
    ["Alignment of body_status"][::std::mem::align_of::<body_status>() - 8usize];
    ["Offset of field: body_status::name"][::std::mem::offset_of!(body_status, name) - 0usize];
    ["Offset of field: body_status::nbr"][::std::mem::offset_of!(body_status, nbr) - 8usize];
    ["Offset of field: body_status::avail"][::std::mem::offset_of!(body_status, avail) - 12usize];
    ["Offset of field: body_status::length_known"]
        [::std::mem::offset_of!(body_status, length_known) - 16usize];
};
impl Default for body_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static BS_NONE: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_ERROR: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_CHUNKED: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_LENGTH: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_EOF: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_TAKEN: [body_status; 1usize];
}
unsafe extern "C" {
    pub static BS_CACHED: [body_status; 1usize];
}
pub type body_status_t = *const body_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stream_close {
    pub magic: ::std::ffi::c_uint,
    pub idx: ::std::ffi::c_int,
    pub is_err: ::std::ffi::c_uint,
    pub name: *const ::std::ffi::c_char,
    pub desc: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stream_close"][::std::mem::size_of::<stream_close>() - 32usize];
    ["Alignment of stream_close"][::std::mem::align_of::<stream_close>() - 8usize];
    ["Offset of field: stream_close::magic"][::std::mem::offset_of!(stream_close, magic) - 0usize];
    ["Offset of field: stream_close::idx"][::std::mem::offset_of!(stream_close, idx) - 4usize];
    ["Offset of field: stream_close::is_err"]
        [::std::mem::offset_of!(stream_close, is_err) - 8usize];
    ["Offset of field: stream_close::name"][::std::mem::offset_of!(stream_close, name) - 16usize];
    ["Offset of field: stream_close::desc"][::std::mem::offset_of!(stream_close, desc) - 24usize];
};
impl Default for stream_close {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static SC_NULL: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_REM_CLOSE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_REQ_CLOSE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_REQ_HTTP10: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_BAD: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_BODY: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_JUNK: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_OVERFLOW: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_TIMEOUT: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RX_CLOSE_IDLE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_TX_PIPE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_TX_ERROR: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_TX_EOF: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RESP_CLOSE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_OVERLOAD: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_PIPE_OVERFLOW: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RANGE_SHORT: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_REQ_HTTP20: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_VCL_FAILURE: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_RAPID_RESET: [stream_close; 1usize];
}
unsafe extern "C" {
    pub static SC_BANKRUPT: [stream_close; 1usize];
}
pub const HTTP_HDR_METHOD: _bindgen_ty_3 = 0;
pub const HTTP_HDR_URL: _bindgen_ty_3 = 1;
pub const HTTP_HDR_PROTO: _bindgen_ty_3 = 2;
pub const HTTP_HDR_STATUS: _bindgen_ty_3 = 3;
pub const HTTP_HDR_REASON: _bindgen_ty_3 = 4;
pub const HTTP_HDR_FIRST: _bindgen_ty_3 = 5;
pub const HTTP_HDR_UNSET: _bindgen_ty_3 = 6;
pub const HTTP_HDR_LOST: _bindgen_ty_3 = 7;
pub type _bindgen_ty_3 = ::std::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban_proto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listen_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objhead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req_step {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_lck {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main_wrk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker_priv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock {
    pub priv_: *mut ::std::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lock"][::std::mem::size_of::<lock>() - 8usize];
    ["Alignment of lock"][::std::mem::align_of::<lock>() - 8usize];
    ["Offset of field: lock::priv_"][::std::mem::offset_of!(lock, priv_) - 0usize];
};
impl Default for lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws {
    pub magic: ::std::ffi::c_uint,
    pub id: [::std::ffi::c_char; 4usize],
    pub s: *mut ::std::ffi::c_char,
    pub f: *mut ::std::ffi::c_char,
    pub r: *mut ::std::ffi::c_char,
    pub e: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ws"][::std::mem::size_of::<ws>() - 40usize];
    ["Alignment of ws"][::std::mem::align_of::<ws>() - 8usize];
    ["Offset of field: ws::magic"][::std::mem::offset_of!(ws, magic) - 0usize];
    ["Offset of field: ws::id"][::std::mem::offset_of!(ws, id) - 4usize];
    ["Offset of field: ws::s"][::std::mem::offset_of!(ws, s) - 8usize];
    ["Offset of field: ws::f"][::std::mem::offset_of!(ws, f) - 16usize];
    ["Offset of field: ws::r"][::std::mem::offset_of!(ws, r) - 24usize];
    ["Offset of field: ws::e"][::std::mem::offset_of!(ws, e) - 32usize];
};
impl Default for ws {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http {
    pub magic: ::std::ffi::c_uint,
    pub shd: u16,
    pub hd: *mut txt,
    pub hdf: *mut ::std::ffi::c_uchar,
    pub nhd: u16,
    pub logtag: VslTag,
    pub vsl: *mut vsl_log,
    pub ws: *mut ws,
    pub status: u16,
    pub protover: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of http"][::std::mem::size_of::<http>() - 56usize];
    ["Alignment of http"][::std::mem::align_of::<http>() - 8usize];
    ["Offset of field: http::magic"][::std::mem::offset_of!(http, magic) - 0usize];
    ["Offset of field: http::shd"][::std::mem::offset_of!(http, shd) - 4usize];
    ["Offset of field: http::hd"][::std::mem::offset_of!(http, hd) - 8usize];
    ["Offset of field: http::hdf"][::std::mem::offset_of!(http, hdf) - 16usize];
    ["Offset of field: http::nhd"][::std::mem::offset_of!(http, nhd) - 24usize];
    ["Offset of field: http::logtag"][::std::mem::offset_of!(http, logtag) - 28usize];
    ["Offset of field: http::vsl"][::std::mem::offset_of!(http, vsl) - 32usize];
    ["Offset of field: http::ws"][::std::mem::offset_of!(http, ws) - 40usize];
    ["Offset of field: http::status"][::std::mem::offset_of!(http, status) - 48usize];
    ["Offset of field: http::protover"][::std::mem::offset_of!(http, protover) - 50usize];
};
impl Default for http {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_req {
    pub req_hdrbytes: u64,
    pub req_bodybytes: u64,
    pub resp_hdrbytes: u64,
    pub resp_bodybytes: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of acct_req"][::std::mem::size_of::<acct_req>() - 32usize];
    ["Alignment of acct_req"][::std::mem::align_of::<acct_req>() - 8usize];
    ["Offset of field: acct_req::req_hdrbytes"]
        [::std::mem::offset_of!(acct_req, req_hdrbytes) - 0usize];
    ["Offset of field: acct_req::req_bodybytes"]
        [::std::mem::offset_of!(acct_req, req_bodybytes) - 8usize];
    ["Offset of field: acct_req::resp_hdrbytes"]
        [::std::mem::offset_of!(acct_req, resp_hdrbytes) - 16usize];
    ["Offset of field: acct_req::resp_bodybytes"]
        [::std::mem::offset_of!(acct_req, resp_bodybytes) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_bereq {
    pub bereq_hdrbytes: u64,
    pub bereq_bodybytes: u64,
    pub beresp_hdrbytes: u64,
    pub beresp_bodybytes: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of acct_bereq"][::std::mem::size_of::<acct_bereq>() - 32usize];
    ["Alignment of acct_bereq"][::std::mem::align_of::<acct_bereq>() - 8usize];
    ["Offset of field: acct_bereq::bereq_hdrbytes"]
        [::std::mem::offset_of!(acct_bereq, bereq_hdrbytes) - 0usize];
    ["Offset of field: acct_bereq::bereq_bodybytes"]
        [::std::mem::offset_of!(acct_bereq, bereq_bodybytes) - 8usize];
    ["Offset of field: acct_bereq::beresp_hdrbytes"]
        [::std::mem::offset_of!(acct_bereq, beresp_hdrbytes) - 16usize];
    ["Offset of field: acct_bereq::beresp_bodybytes"]
        [::std::mem::offset_of!(acct_bereq, beresp_bodybytes) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_log {
    pub wlb: *mut u32,
    pub wlp: *mut u32,
    pub wle: *mut u32,
    pub wid: vxid_t,
    pub wlr: ::std::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsl_log"][::std::mem::size_of::<vsl_log>() - 40usize];
    ["Alignment of vsl_log"][::std::mem::align_of::<vsl_log>() - 8usize];
    ["Offset of field: vsl_log::wlb"][::std::mem::offset_of!(vsl_log, wlb) - 0usize];
    ["Offset of field: vsl_log::wlp"][::std::mem::offset_of!(vsl_log, wlp) - 8usize];
    ["Offset of field: vsl_log::wle"][::std::mem::offset_of!(vsl_log, wle) - 16usize];
    ["Offset of field: vsl_log::wid"][::std::mem::offset_of!(vsl_log, wid) - 24usize];
    ["Offset of field: vsl_log::wlr"][::std::mem::offset_of!(vsl_log, wlr) - 32usize];
};
impl Default for vsl_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_privs {
    pub rbh_root: *mut vrt_priv,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vrt_privs"][::std::mem::size_of::<vrt_privs>() - 8usize];
    ["Alignment of vrt_privs"][::std::mem::align_of::<vrt_privs>() - 8usize];
    ["Offset of field: vrt_privs::rbh_root"][::std::mem::offset_of!(vrt_privs, rbh_root) - 0usize];
};
impl Default for vrt_privs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type task_func_t =
    ::std::option::Option<unsafe extern "C" fn(wrk: *mut worker, priv_: *mut ::std::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task {
    pub list: pool_task__bindgen_ty_1,
    pub func: task_func_t,
    pub priv_: *mut ::std::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task__bindgen_ty_1 {
    pub vtqe_next: *mut pool_task,
    pub vtqe_prev: *mut *mut pool_task,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pool_task__bindgen_ty_1"][::std::mem::size_of::<pool_task__bindgen_ty_1>() - 16usize];
    ["Alignment of pool_task__bindgen_ty_1"]
        [::std::mem::align_of::<pool_task__bindgen_ty_1>() - 8usize];
    ["Offset of field: pool_task__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(pool_task__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: pool_task__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(pool_task__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for pool_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pool_task"][::std::mem::size_of::<pool_task>() - 32usize];
    ["Alignment of pool_task"][::std::mem::align_of::<pool_task>() - 8usize];
    ["Offset of field: pool_task::list"][::std::mem::offset_of!(pool_task, list) - 0usize];
    ["Offset of field: pool_task::func"][::std::mem::offset_of!(pool_task, func) - 16usize];
    ["Offset of field: pool_task::priv_"][::std::mem::offset_of!(pool_task, priv_) - 24usize];
};
impl Default for pool_task {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TaskPriority {
    Bo = 0,
    Rush = 1,
    Req = 2,
    Str = 3,
    Vca = 4,
    Bg = 5,
    End = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker {
    pub magic: ::std::ffi::c_uint,
    pub strangelove: ::std::ffi::c_int,
    pub wpriv: *mut worker_priv,
    pub pool: *mut pool,
    pub stats: *mut VSC_main_wrk,
    pub vsl: *mut vsl_log,
    pub task: [pool_task; 1usize],
    pub lastused: vtim_real,
    pub cond: pthread_cond_t,
    pub aws: [ws; 1usize],
    pub cur_method: ::std::ffi::c_uint,
    pub seen_methods: ::std::ffi::c_uint,
    pub vpi: *mut wrk_vpi,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of worker"][::std::mem::size_of::<worker>() - 184usize];
    ["Alignment of worker"][::std::mem::align_of::<worker>() - 8usize];
    ["Offset of field: worker::magic"][::std::mem::offset_of!(worker, magic) - 0usize];
    ["Offset of field: worker::strangelove"][::std::mem::offset_of!(worker, strangelove) - 4usize];
    ["Offset of field: worker::wpriv"][::std::mem::offset_of!(worker, wpriv) - 8usize];
    ["Offset of field: worker::pool"][::std::mem::offset_of!(worker, pool) - 16usize];
    ["Offset of field: worker::stats"][::std::mem::offset_of!(worker, stats) - 24usize];
    ["Offset of field: worker::vsl"][::std::mem::offset_of!(worker, vsl) - 32usize];
    ["Offset of field: worker::task"][::std::mem::offset_of!(worker, task) - 40usize];
    ["Offset of field: worker::lastused"][::std::mem::offset_of!(worker, lastused) - 72usize];
    ["Offset of field: worker::cond"][::std::mem::offset_of!(worker, cond) - 80usize];
    ["Offset of field: worker::aws"][::std::mem::offset_of!(worker, aws) - 128usize];
    ["Offset of field: worker::cur_method"][::std::mem::offset_of!(worker, cur_method) - 168usize];
    ["Offset of field: worker::seen_methods"]
        [::std::mem::offset_of!(worker, seen_methods) - 172usize];
    ["Offset of field: worker::vpi"][::std::mem::offset_of!(worker, vpi) - 176usize];
};
impl Default for worker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storeobj {
    pub stevedore: *const stevedore,
    pub priv_: *mut ::std::ffi::c_void,
    pub priv2: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of storeobj"][::std::mem::size_of::<storeobj>() - 24usize];
    ["Alignment of storeobj"][::std::mem::align_of::<storeobj>() - 8usize];
    ["Offset of field: storeobj::stevedore"][::std::mem::offset_of!(storeobj, stevedore) - 0usize];
    ["Offset of field: storeobj::priv_"][::std::mem::offset_of!(storeobj, priv_) - 8usize];
    ["Offset of field: storeobj::priv2"][::std::mem::offset_of!(storeobj, priv2) - 16usize];
};
impl Default for storeobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BocState {
    Invalid = 0,
    ReqDone = 1,
    Stream = 2,
    Finished = 3,
    Failed = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vai_qe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vai_q_head {
    pub vslh_first: *mut vai_qe,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vai_q_head"][::std::mem::size_of::<vai_q_head>() - 8usize];
    ["Alignment of vai_q_head"][::std::mem::align_of::<vai_q_head>() - 8usize];
    ["Offset of field: vai_q_head::vslh_first"]
        [::std::mem::offset_of!(vai_q_head, vslh_first) - 0usize];
};
impl Default for vai_q_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boc {
    pub magic: ::std::ffi::c_uint,
    pub refcount: ::std::ffi::c_uint,
    pub mtx: lock,
    pub cond: pthread_cond_t,
    pub stevedore_priv: *mut ::std::ffi::c_void,
    pub state: BocState,
    pub vary: *mut u8,
    pub fetched_so_far: u64,
    pub delivered_so_far: u64,
    pub transit_buffer: u64,
    pub vai_q_head: vai_q_head,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of boc"][::std::mem::size_of::<boc>() - 120usize];
    ["Alignment of boc"][::std::mem::align_of::<boc>() - 8usize];
    ["Offset of field: boc::magic"][::std::mem::offset_of!(boc, magic) - 0usize];
    ["Offset of field: boc::refcount"][::std::mem::offset_of!(boc, refcount) - 4usize];
    ["Offset of field: boc::mtx"][::std::mem::offset_of!(boc, mtx) - 8usize];
    ["Offset of field: boc::cond"][::std::mem::offset_of!(boc, cond) - 16usize];
    ["Offset of field: boc::stevedore_priv"][::std::mem::offset_of!(boc, stevedore_priv) - 64usize];
    ["Offset of field: boc::state"][::std::mem::offset_of!(boc, state) - 72usize];
    ["Offset of field: boc::vary"][::std::mem::offset_of!(boc, vary) - 80usize];
    ["Offset of field: boc::fetched_so_far"][::std::mem::offset_of!(boc, fetched_so_far) - 88usize];
    ["Offset of field: boc::delivered_so_far"]
        [::std::mem::offset_of!(boc, delivered_so_far) - 96usize];
    ["Offset of field: boc::transit_buffer"]
        [::std::mem::offset_of!(boc, transit_buffer) - 104usize];
    ["Offset of field: boc::vai_q_head"][::std::mem::offset_of!(boc, vai_q_head) - 112usize];
};
impl Default for boc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const obj_attr_OA_LEN: obj_attr = 0;
pub const obj_attr_OA_VXID: obj_attr = 1;
pub const obj_attr_OA_FLAGS: obj_attr = 2;
pub const obj_attr_OA_GZIPBITS: obj_attr = 3;
pub const obj_attr_OA_LASTMODIFIED: obj_attr = 4;
pub const obj_attr_OA_VARY: obj_attr = 5;
pub const obj_attr_OA_HEADERS: obj_attr = 6;
pub const obj_attr_OA_ESIDATA: obj_attr = 7;
pub const obj_attr_OA__MAX: obj_attr = 8;
pub type obj_attr = ::std::ffi::c_uint;
pub const obj_flags_OF_GZIPED: obj_flags = 2;
pub const obj_flags_OF_CHGCE: obj_flags = 4;
pub const obj_flags_OF_IMSCAND: obj_flags = 8;
pub const obj_flags_OF_ESIPROC: obj_flags = 16;
pub type obj_flags = ::std::ffi::c_uint;
pub const oc_flags_OC_F_WITHDRAWN: oc_flags = 1;
pub const oc_flags_OC_F_BUSY: oc_flags = 2;
pub const oc_flags_OC_F_HFM: oc_flags = 4;
pub const oc_flags_OC_F_HFP: oc_flags = 8;
pub const oc_flags_OC_F_CANCEL: oc_flags = 16;
pub const oc_flags_OC_F_PRIVATE: oc_flags = 32;
pub const oc_flags_OC_F_FAILED: oc_flags = 64;
pub const oc_flags_OC_F_DYING: oc_flags = 128;
pub type oc_flags = ::std::ffi::c_uint;
pub const oc_exp_flags_OC_EF_POSTED: oc_exp_flags = 2;
pub const oc_exp_flags_OC_EF_REFD: oc_exp_flags = 4;
pub const oc_exp_flags_OC_EF_MOVE: oc_exp_flags = 8;
pub const oc_exp_flags_OC_EF_INSERT: oc_exp_flags = 16;
pub const oc_exp_flags_OC_EF_REMOVE: oc_exp_flags = 32;
pub const oc_exp_flags_OC_EF_NEW: oc_exp_flags = 64;
pub type oc_exp_flags = ::std::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore {
    pub magic: ::std::ffi::c_uint,
    pub refcnt: ::std::ffi::c_int,
    pub stobj: [storeobj; 1usize],
    pub objhead: *mut objhead,
    pub boc: *mut boc,
    pub timer_when: vtim_real,
    pub hits: VCL_INT,
    pub t_origin: vtim_real,
    pub ttl: f32,
    pub grace: f32,
    pub keep: f32,
    pub flags: u8,
    pub exp_flags: u8,
    pub oa_present: u16,
    pub timer_idx: ::std::ffi::c_uint,
    pub waitinglist_gen: ::std::ffi::c_uint,
    pub last_lru: vtim_real,
    pub hsh_list: objcore__bindgen_ty_1,
    pub lru_list: objcore__bindgen_ty_2,
    pub ban_list: objcore__bindgen_ty_3,
    pub exp_list: objcore__bindgen_ty_4,
    pub ban: *mut ban,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_1 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of objcore__bindgen_ty_1"][::std::mem::size_of::<objcore__bindgen_ty_1>() - 16usize];
    ["Alignment of objcore__bindgen_ty_1"]
        [::std::mem::align_of::<objcore__bindgen_ty_1>() - 8usize];
    ["Offset of field: objcore__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(objcore__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: objcore__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(objcore__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for objcore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_2 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of objcore__bindgen_ty_2"][::std::mem::size_of::<objcore__bindgen_ty_2>() - 16usize];
    ["Alignment of objcore__bindgen_ty_2"]
        [::std::mem::align_of::<objcore__bindgen_ty_2>() - 8usize];
    ["Offset of field: objcore__bindgen_ty_2::vtqe_next"]
        [::std::mem::offset_of!(objcore__bindgen_ty_2, vtqe_next) - 0usize];
    ["Offset of field: objcore__bindgen_ty_2::vtqe_prev"]
        [::std::mem::offset_of!(objcore__bindgen_ty_2, vtqe_prev) - 8usize];
};
impl Default for objcore__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_3 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of objcore__bindgen_ty_3"][::std::mem::size_of::<objcore__bindgen_ty_3>() - 16usize];
    ["Alignment of objcore__bindgen_ty_3"]
        [::std::mem::align_of::<objcore__bindgen_ty_3>() - 8usize];
    ["Offset of field: objcore__bindgen_ty_3::vtqe_next"]
        [::std::mem::offset_of!(objcore__bindgen_ty_3, vtqe_next) - 0usize];
    ["Offset of field: objcore__bindgen_ty_3::vtqe_prev"]
        [::std::mem::offset_of!(objcore__bindgen_ty_3, vtqe_prev) - 8usize];
};
impl Default for objcore__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_4 {
    pub vstqe_next: *mut objcore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of objcore__bindgen_ty_4"][::std::mem::size_of::<objcore__bindgen_ty_4>() - 8usize];
    ["Alignment of objcore__bindgen_ty_4"]
        [::std::mem::align_of::<objcore__bindgen_ty_4>() - 8usize];
    ["Offset of field: objcore__bindgen_ty_4::vstqe_next"]
        [::std::mem::offset_of!(objcore__bindgen_ty_4, vstqe_next) - 0usize];
};
impl Default for objcore__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of objcore"][::std::mem::size_of::<objcore>() - 168usize];
    ["Alignment of objcore"][::std::mem::align_of::<objcore>() - 8usize];
    ["Offset of field: objcore::magic"][::std::mem::offset_of!(objcore, magic) - 0usize];
    ["Offset of field: objcore::refcnt"][::std::mem::offset_of!(objcore, refcnt) - 4usize];
    ["Offset of field: objcore::stobj"][::std::mem::offset_of!(objcore, stobj) - 8usize];
    ["Offset of field: objcore::objhead"][::std::mem::offset_of!(objcore, objhead) - 32usize];
    ["Offset of field: objcore::boc"][::std::mem::offset_of!(objcore, boc) - 40usize];
    ["Offset of field: objcore::timer_when"][::std::mem::offset_of!(objcore, timer_when) - 48usize];
    ["Offset of field: objcore::hits"][::std::mem::offset_of!(objcore, hits) - 56usize];
    ["Offset of field: objcore::t_origin"][::std::mem::offset_of!(objcore, t_origin) - 64usize];
    ["Offset of field: objcore::ttl"][::std::mem::offset_of!(objcore, ttl) - 72usize];
    ["Offset of field: objcore::grace"][::std::mem::offset_of!(objcore, grace) - 76usize];
    ["Offset of field: objcore::keep"][::std::mem::offset_of!(objcore, keep) - 80usize];
    ["Offset of field: objcore::flags"][::std::mem::offset_of!(objcore, flags) - 84usize];
    ["Offset of field: objcore::exp_flags"][::std::mem::offset_of!(objcore, exp_flags) - 85usize];
    ["Offset of field: objcore::oa_present"][::std::mem::offset_of!(objcore, oa_present) - 86usize];
    ["Offset of field: objcore::timer_idx"][::std::mem::offset_of!(objcore, timer_idx) - 88usize];
    ["Offset of field: objcore::waitinglist_gen"]
        [::std::mem::offset_of!(objcore, waitinglist_gen) - 92usize];
    ["Offset of field: objcore::last_lru"][::std::mem::offset_of!(objcore, last_lru) - 96usize];
    ["Offset of field: objcore::hsh_list"][::std::mem::offset_of!(objcore, hsh_list) - 104usize];
    ["Offset of field: objcore::lru_list"][::std::mem::offset_of!(objcore, lru_list) - 120usize];
    ["Offset of field: objcore::ban_list"][::std::mem::offset_of!(objcore, ban_list) - 136usize];
    ["Offset of field: objcore::exp_list"][::std::mem::offset_of!(objcore, exp_list) - 152usize];
    ["Offset of field: objcore::ban"][::std::mem::offset_of!(objcore, ban) - 160usize];
};
impl Default for objcore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DirectorState {
    Null = 0,
    Headers = 1,
    Body = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct busyobj {
    pub magic: ::std::ffi::c_uint,
    pub end: *mut ::std::ffi::c_char,
    pub max_retries: ::std::ffi::c_uint,
    pub retries: ::std::ffi::c_uint,
    pub req: *mut req,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub vfc: *mut vfp_ctx,
    pub vfp_filter_list: *const ::std::ffi::c_char,
    pub vdp_filter_list: *const ::std::ffi::c_char,
    pub ws: [ws; 1usize],
    pub ws_bo: usize,
    pub bereq0: *mut http,
    pub bereq: *mut http,
    pub beresp: *mut http,
    pub bereq_body: *mut objcore,
    pub stale_oc: *mut objcore,
    pub fetch_objcore: *mut objcore,
    pub no_retry: *const ::std::ffi::c_char,
    pub htc: *mut http_conn,
    pub fetch_task: [pool_task; 1usize],
    pub err_reason: *const ::std::ffi::c_char,
    pub director_state: DirectorState,
    pub err_code: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub task_deadline: vtim_dur,
    pub t_first: vtim_real,
    pub t_resp: vtim_real,
    pub t_prev: vtim_real,
    pub acct: acct_bereq,
    pub storage: *const stevedore,
    pub director_req: *const director,
    pub director_resp: *const director,
    pub vcl: *mut vcl,
    pub vsl: [vsl_log; 1usize],
    pub digest: [u8; 32usize],
    pub privs: [vrt_privs; 1usize],
    pub client_identity: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of busyobj"][::std::mem::size_of::<busyobj>() - 440usize];
    ["Alignment of busyobj"][::std::mem::align_of::<busyobj>() - 8usize];
    ["Offset of field: busyobj::magic"][::std::mem::offset_of!(busyobj, magic) - 0usize];
    ["Offset of field: busyobj::end"][::std::mem::offset_of!(busyobj, end) - 8usize];
    ["Offset of field: busyobj::max_retries"]
        [::std::mem::offset_of!(busyobj, max_retries) - 16usize];
    ["Offset of field: busyobj::retries"][::std::mem::offset_of!(busyobj, retries) - 20usize];
    ["Offset of field: busyobj::req"][::std::mem::offset_of!(busyobj, req) - 24usize];
    ["Offset of field: busyobj::sp"][::std::mem::offset_of!(busyobj, sp) - 32usize];
    ["Offset of field: busyobj::wrk"][::std::mem::offset_of!(busyobj, wrk) - 40usize];
    ["Offset of field: busyobj::vfc"][::std::mem::offset_of!(busyobj, vfc) - 48usize];
    ["Offset of field: busyobj::vfp_filter_list"]
        [::std::mem::offset_of!(busyobj, vfp_filter_list) - 56usize];
    ["Offset of field: busyobj::vdp_filter_list"]
        [::std::mem::offset_of!(busyobj, vdp_filter_list) - 64usize];
    ["Offset of field: busyobj::ws"][::std::mem::offset_of!(busyobj, ws) - 72usize];
    ["Offset of field: busyobj::ws_bo"][::std::mem::offset_of!(busyobj, ws_bo) - 112usize];
    ["Offset of field: busyobj::bereq0"][::std::mem::offset_of!(busyobj, bereq0) - 120usize];
    ["Offset of field: busyobj::bereq"][::std::mem::offset_of!(busyobj, bereq) - 128usize];
    ["Offset of field: busyobj::beresp"][::std::mem::offset_of!(busyobj, beresp) - 136usize];
    ["Offset of field: busyobj::bereq_body"]
        [::std::mem::offset_of!(busyobj, bereq_body) - 144usize];
    ["Offset of field: busyobj::stale_oc"][::std::mem::offset_of!(busyobj, stale_oc) - 152usize];
    ["Offset of field: busyobj::fetch_objcore"]
        [::std::mem::offset_of!(busyobj, fetch_objcore) - 160usize];
    ["Offset of field: busyobj::no_retry"][::std::mem::offset_of!(busyobj, no_retry) - 168usize];
    ["Offset of field: busyobj::htc"][::std::mem::offset_of!(busyobj, htc) - 176usize];
    ["Offset of field: busyobj::fetch_task"]
        [::std::mem::offset_of!(busyobj, fetch_task) - 184usize];
    ["Offset of field: busyobj::err_reason"]
        [::std::mem::offset_of!(busyobj, err_reason) - 216usize];
    ["Offset of field: busyobj::director_state"]
        [::std::mem::offset_of!(busyobj, director_state) - 224usize];
    ["Offset of field: busyobj::err_code"][::std::mem::offset_of!(busyobj, err_code) - 228usize];
    ["Offset of field: busyobj::connect_timeout"]
        [::std::mem::offset_of!(busyobj, connect_timeout) - 232usize];
    ["Offset of field: busyobj::first_byte_timeout"]
        [::std::mem::offset_of!(busyobj, first_byte_timeout) - 240usize];
    ["Offset of field: busyobj::between_bytes_timeout"]
        [::std::mem::offset_of!(busyobj, between_bytes_timeout) - 248usize];
    ["Offset of field: busyobj::task_deadline"]
        [::std::mem::offset_of!(busyobj, task_deadline) - 256usize];
    ["Offset of field: busyobj::t_first"][::std::mem::offset_of!(busyobj, t_first) - 264usize];
    ["Offset of field: busyobj::t_resp"][::std::mem::offset_of!(busyobj, t_resp) - 272usize];
    ["Offset of field: busyobj::t_prev"][::std::mem::offset_of!(busyobj, t_prev) - 280usize];
    ["Offset of field: busyobj::acct"][::std::mem::offset_of!(busyobj, acct) - 288usize];
    ["Offset of field: busyobj::storage"][::std::mem::offset_of!(busyobj, storage) - 320usize];
    ["Offset of field: busyobj::director_req"]
        [::std::mem::offset_of!(busyobj, director_req) - 328usize];
    ["Offset of field: busyobj::director_resp"]
        [::std::mem::offset_of!(busyobj, director_resp) - 336usize];
    ["Offset of field: busyobj::vcl"][::std::mem::offset_of!(busyobj, vcl) - 344usize];
    ["Offset of field: busyobj::vsl"][::std::mem::offset_of!(busyobj, vsl) - 352usize];
    ["Offset of field: busyobj::digest"][::std::mem::offset_of!(busyobj, digest) - 392usize];
    ["Offset of field: busyobj::privs"][::std::mem::offset_of!(busyobj, privs) - 424usize];
    ["Offset of field: busyobj::client_identity"]
        [::std::mem::offset_of!(busyobj, client_identity) - 432usize];
};
impl Default for busyobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl busyobj {
    #[inline]
    pub fn uncacheable(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uncacheable(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uncacheable_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uncacheable_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_bgfetch(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bgfetch(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_bgfetch_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_bgfetch_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hitmiss_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hitmiss_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hitpass_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hitpass_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trace_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trace_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_esi(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_esi(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_esi_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_esi_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_gzip(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gzip(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_gzip_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_gzip_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_gunzip(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gunzip(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_gunzip_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_gunzip_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_stream(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_stream(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_stream_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_stream_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn was_304(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_304(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn was_304_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_was_304_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uncacheable: ::std::ffi::c_uint,
        is_bgfetch: ::std::ffi::c_uint,
        is_hitmiss: ::std::ffi::c_uint,
        is_hitpass: ::std::ffi::c_uint,
        trace: ::std::ffi::c_uint,
        do_esi: ::std::ffi::c_uint,
        do_gzip: ::std::ffi::c_uint,
        do_gunzip: ::std::ffi::c_uint,
        do_stream: ::std::ffi::c_uint,
        was_304: ::std::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uncacheable: u32 = unsafe { ::std::mem::transmute(uncacheable) };
            uncacheable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_bgfetch: u32 = unsafe { ::std::mem::transmute(is_bgfetch) };
            is_bgfetch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let trace: u32 = unsafe { ::std::mem::transmute(trace) };
            trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let do_esi: u32 = unsafe { ::std::mem::transmute(do_esi) };
            do_esi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let do_gzip: u32 = unsafe { ::std::mem::transmute(do_gzip) };
            do_gzip as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let do_gunzip: u32 = unsafe { ::std::mem::transmute(do_gunzip) };
            do_gunzip as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let do_stream: u32 = unsafe { ::std::mem::transmute(do_stream) };
            do_stream as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let was_304: u32 = unsafe { ::std::mem::transmute(was_304) };
            was_304 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reqtop {
    pub magic: ::std::ffi::c_uint,
    pub topreq: *mut req,
    pub vcl0: *mut vcl,
    pub privs: [vrt_privs; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of reqtop"][::std::mem::size_of::<reqtop>() - 32usize];
    ["Alignment of reqtop"][::std::mem::align_of::<reqtop>() - 8usize];
    ["Offset of field: reqtop::magic"][::std::mem::offset_of!(reqtop, magic) - 0usize];
    ["Offset of field: reqtop::topreq"][::std::mem::offset_of!(reqtop, topreq) - 8usize];
    ["Offset of field: reqtop::vcl0"][::std::mem::offset_of!(reqtop, vcl0) - 16usize];
    ["Offset of field: reqtop::privs"][::std::mem::offset_of!(reqtop, privs) - 24usize];
};
impl Default for reqtop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req {
    pub magic: ::std::ffi::c_uint,
    pub esi_level: ::std::ffi::c_uint,
    pub req_body_status: body_status_t,
    pub doclose: stream_close_t,
    pub restarts: ::std::ffi::c_uint,
    pub max_restarts: ::std::ffi::c_uint,
    pub waitinglist_gen: ::std::ffi::c_uint,
    pub req_step: *const req_step,
    pub top: *mut reqtop,
    pub err_code: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub err_reason: *const ::std::ffi::c_char,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub task: [pool_task; 1usize],
    pub transport: *const transport,
    pub transport_priv: *mut ::std::ffi::c_void,
    pub w_list: req__bindgen_ty_1,
    pub body_oc: *mut objcore,
    pub vary_b: *mut u8,
    pub vary_e: *mut u8,
    pub digest: [u8; 32usize],
    pub d_ttl: vtim_dur,
    pub d_grace: vtim_dur,
    pub storage: *const stevedore,
    pub director_hint: *const director,
    pub vcl: *mut vcl,
    pub ws_req: usize,
    pub t_first: vtim_real,
    pub t_prev: vtim_real,
    pub t_req: vtim_real,
    pub t_resp: vtim_real,
    pub htc: *mut http_conn,
    pub vfc: *mut vfp_ctx,
    pub client_identity: *const ::std::ffi::c_char,
    pub http: *mut http,
    pub http0: *mut http,
    pub resp: *mut http,
    pub resp_len: intmax_t,
    pub ws: [ws; 1usize],
    pub objcore: *mut objcore,
    pub stale_oc: *mut objcore,
    pub boc: *mut boc,
    pub vdc: *mut vdp_ctx,
    pub vdp_filter_list: *const ::std::ffi::c_char,
    pub vfp_filter_list: *const ::std::ffi::c_char,
    pub vsl: [vsl_log; 1usize],
    pub acct: acct_req,
    pub privs: [vrt_privs; 1usize],
    pub vcf: *mut vcf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req__bindgen_ty_1 {
    pub vtqe_next: *mut req,
    pub vtqe_prev: *mut *mut req,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of req__bindgen_ty_1"][::std::mem::size_of::<req__bindgen_ty_1>() - 16usize];
    ["Alignment of req__bindgen_ty_1"][::std::mem::align_of::<req__bindgen_ty_1>() - 8usize];
    ["Offset of field: req__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(req__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: req__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(req__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for req__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of req"][::std::mem::size_of::<req>() - 520usize];
    ["Alignment of req"][::std::mem::align_of::<req>() - 8usize];
    ["Offset of field: req::magic"][::std::mem::offset_of!(req, magic) - 0usize];
    ["Offset of field: req::esi_level"][::std::mem::offset_of!(req, esi_level) - 4usize];
    ["Offset of field: req::req_body_status"]
        [::std::mem::offset_of!(req, req_body_status) - 8usize];
    ["Offset of field: req::doclose"][::std::mem::offset_of!(req, doclose) - 16usize];
    ["Offset of field: req::restarts"][::std::mem::offset_of!(req, restarts) - 24usize];
    ["Offset of field: req::max_restarts"][::std::mem::offset_of!(req, max_restarts) - 28usize];
    ["Offset of field: req::waitinglist_gen"]
        [::std::mem::offset_of!(req, waitinglist_gen) - 32usize];
    ["Offset of field: req::req_step"][::std::mem::offset_of!(req, req_step) - 40usize];
    ["Offset of field: req::top"][::std::mem::offset_of!(req, top) - 48usize];
    ["Offset of field: req::err_code"][::std::mem::offset_of!(req, err_code) - 56usize];
    ["Offset of field: req::err_reason"][::std::mem::offset_of!(req, err_reason) - 64usize];
    ["Offset of field: req::sp"][::std::mem::offset_of!(req, sp) - 72usize];
    ["Offset of field: req::wrk"][::std::mem::offset_of!(req, wrk) - 80usize];
    ["Offset of field: req::task"][::std::mem::offset_of!(req, task) - 88usize];
    ["Offset of field: req::transport"][::std::mem::offset_of!(req, transport) - 120usize];
    ["Offset of field: req::transport_priv"]
        [::std::mem::offset_of!(req, transport_priv) - 128usize];
    ["Offset of field: req::w_list"][::std::mem::offset_of!(req, w_list) - 136usize];
    ["Offset of field: req::body_oc"][::std::mem::offset_of!(req, body_oc) - 152usize];
    ["Offset of field: req::vary_b"][::std::mem::offset_of!(req, vary_b) - 160usize];
    ["Offset of field: req::vary_e"][::std::mem::offset_of!(req, vary_e) - 168usize];
    ["Offset of field: req::digest"][::std::mem::offset_of!(req, digest) - 176usize];
    ["Offset of field: req::d_ttl"][::std::mem::offset_of!(req, d_ttl) - 208usize];
    ["Offset of field: req::d_grace"][::std::mem::offset_of!(req, d_grace) - 216usize];
    ["Offset of field: req::storage"][::std::mem::offset_of!(req, storage) - 224usize];
    ["Offset of field: req::director_hint"][::std::mem::offset_of!(req, director_hint) - 232usize];
    ["Offset of field: req::vcl"][::std::mem::offset_of!(req, vcl) - 240usize];
    ["Offset of field: req::ws_req"][::std::mem::offset_of!(req, ws_req) - 248usize];
    ["Offset of field: req::t_first"][::std::mem::offset_of!(req, t_first) - 256usize];
    ["Offset of field: req::t_prev"][::std::mem::offset_of!(req, t_prev) - 264usize];
    ["Offset of field: req::t_req"][::std::mem::offset_of!(req, t_req) - 272usize];
    ["Offset of field: req::t_resp"][::std::mem::offset_of!(req, t_resp) - 280usize];
    ["Offset of field: req::htc"][::std::mem::offset_of!(req, htc) - 288usize];
    ["Offset of field: req::vfc"][::std::mem::offset_of!(req, vfc) - 296usize];
    ["Offset of field: req::client_identity"]
        [::std::mem::offset_of!(req, client_identity) - 304usize];
    ["Offset of field: req::http"][::std::mem::offset_of!(req, http) - 312usize];
    ["Offset of field: req::http0"][::std::mem::offset_of!(req, http0) - 320usize];
    ["Offset of field: req::resp"][::std::mem::offset_of!(req, resp) - 328usize];
    ["Offset of field: req::resp_len"][::std::mem::offset_of!(req, resp_len) - 336usize];
    ["Offset of field: req::ws"][::std::mem::offset_of!(req, ws) - 344usize];
    ["Offset of field: req::objcore"][::std::mem::offset_of!(req, objcore) - 384usize];
    ["Offset of field: req::stale_oc"][::std::mem::offset_of!(req, stale_oc) - 392usize];
    ["Offset of field: req::boc"][::std::mem::offset_of!(req, boc) - 400usize];
    ["Offset of field: req::vdc"][::std::mem::offset_of!(req, vdc) - 408usize];
    ["Offset of field: req::vdp_filter_list"]
        [::std::mem::offset_of!(req, vdp_filter_list) - 416usize];
    ["Offset of field: req::vfp_filter_list"]
        [::std::mem::offset_of!(req, vfp_filter_list) - 424usize];
    ["Offset of field: req::vsl"][::std::mem::offset_of!(req, vsl) - 432usize];
    ["Offset of field: req::acct"][::std::mem::offset_of!(req, acct) - 472usize];
    ["Offset of field: req::privs"][::std::mem::offset_of!(req, privs) - 504usize];
    ["Offset of field: req::vcf"][::std::mem::offset_of!(req, vcf) - 512usize];
};
impl Default for req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl req {
    #[inline]
    pub fn disable_esi(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_esi(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_esi_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disable_esi_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hash_ignore_busy(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_busy(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hash_ignore_busy_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hash_ignore_busy_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hash_ignore_vary(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_vary(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hash_ignore_vary_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hash_ignore_vary_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hash_always_miss(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_always_miss(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hash_always_miss_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hash_always_miss_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hit(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hit(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hit_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hit_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn want100cont(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want100cont(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn want100cont_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_want100cont_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn late100cont(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_late100cont(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn late100cont_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_late100cont_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn req_reset(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_req_reset(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn req_reset_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_req_reset_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res_esi(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_res_esi(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_esi_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_esi_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res_pipe(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_res_pipe(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_pipe_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_pipe_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hitmiss_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hitmiss_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hitpass_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hitpass_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::ffi::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trace_raw(this: *const Self) -> ::std::ffi::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trace_raw(this: *mut Self, val: ::std::ffi::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_esi: ::std::ffi::c_uint,
        hash_ignore_busy: ::std::ffi::c_uint,
        hash_ignore_vary: ::std::ffi::c_uint,
        hash_always_miss: ::std::ffi::c_uint,
        is_hit: ::std::ffi::c_uint,
        want100cont: ::std::ffi::c_uint,
        late100cont: ::std::ffi::c_uint,
        req_reset: ::std::ffi::c_uint,
        res_esi: ::std::ffi::c_uint,
        res_pipe: ::std::ffi::c_uint,
        is_hitmiss: ::std::ffi::c_uint,
        is_hitpass: ::std::ffi::c_uint,
        trace: ::std::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_esi: u32 = unsafe { ::std::mem::transmute(disable_esi) };
            disable_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hash_ignore_busy: u32 = unsafe { ::std::mem::transmute(hash_ignore_busy) };
            hash_ignore_busy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hash_ignore_vary: u32 = unsafe { ::std::mem::transmute(hash_ignore_vary) };
            hash_ignore_vary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hash_always_miss: u32 = unsafe { ::std::mem::transmute(hash_always_miss) };
            hash_always_miss as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_hit: u32 = unsafe { ::std::mem::transmute(is_hit) };
            is_hit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let want100cont: u32 = unsafe { ::std::mem::transmute(want100cont) };
            want100cont as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let late100cont: u32 = unsafe { ::std::mem::transmute(late100cont) };
            late100cont as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let req_reset: u32 = unsafe { ::std::mem::transmute(req_reset) };
            req_reset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let res_esi: u32 = unsafe { ::std::mem::transmute(res_esi) };
            res_esi as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let res_pipe: u32 = unsafe { ::std::mem::transmute(res_pipe) };
            res_pipe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let trace: u32 = unsafe { ::std::mem::transmute(trace) };
            trace as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SessionAttr {
    Transport = 0,
    RemoteAddr = 1,
    LocalAddr = 2,
    ClientAddr = 3,
    ServerAddr = 4,
    ClientIp = 5,
    ClientPort = 6,
    ProxyTlv = 7,
    ProtoPriv = 8,
    Last = 9,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess {
    pub magic: ::std::ffi::c_uint,
    pub sattr: [u16; 9usize],
    pub listen_sock: *mut listen_sock,
    pub refcnt: ::std::ffi::c_int,
    pub fd: ::std::ffi::c_int,
    pub vxid: vxid_t,
    pub mtx: lock,
    pub pool: *mut pool,
    pub ws: [ws; 1usize],
    pub t_open: vtim_real,
    pub t_idle: vtim_real,
    pub timeout_idle: vtim_dur,
    pub timeout_linger: vtim_dur,
    pub send_timeout: vtim_dur,
    pub idle_send_timeout: vtim_dur,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sess"][::std::mem::size_of::<sess>() - 152usize];
    ["Alignment of sess"][::std::mem::align_of::<sess>() - 8usize];
    ["Offset of field: sess::magic"][::std::mem::offset_of!(sess, magic) - 0usize];
    ["Offset of field: sess::sattr"][::std::mem::offset_of!(sess, sattr) - 4usize];
    ["Offset of field: sess::listen_sock"][::std::mem::offset_of!(sess, listen_sock) - 24usize];
    ["Offset of field: sess::refcnt"][::std::mem::offset_of!(sess, refcnt) - 32usize];
    ["Offset of field: sess::fd"][::std::mem::offset_of!(sess, fd) - 36usize];
    ["Offset of field: sess::vxid"][::std::mem::offset_of!(sess, vxid) - 40usize];
    ["Offset of field: sess::mtx"][::std::mem::offset_of!(sess, mtx) - 48usize];
    ["Offset of field: sess::pool"][::std::mem::offset_of!(sess, pool) - 56usize];
    ["Offset of field: sess::ws"][::std::mem::offset_of!(sess, ws) - 64usize];
    ["Offset of field: sess::t_open"][::std::mem::offset_of!(sess, t_open) - 104usize];
    ["Offset of field: sess::t_idle"][::std::mem::offset_of!(sess, t_idle) - 112usize];
    ["Offset of field: sess::timeout_idle"][::std::mem::offset_of!(sess, timeout_idle) - 120usize];
    ["Offset of field: sess::timeout_linger"]
        [::std::mem::offset_of!(sess, timeout_linger) - 128usize];
    ["Offset of field: sess::send_timeout"][::std::mem::offset_of!(sess, send_timeout) - 136usize];
    ["Offset of field: sess::idle_send_timeout"]
        [::std::mem::offset_of!(sess, idle_send_timeout) - 144usize];
};
impl Default for sess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn BAN_Build() -> *mut ban_proto;
}
unsafe extern "C" {
    pub fn BAN_AddTest(
        arg1: *mut ban_proto,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
        arg4: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn BAN_Commit(b: *mut ban_proto) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn BAN_Abandon(b: *mut ban_proto);
}
unsafe extern "C" {
    pub static mut cli_thread: pthread_t;
}
unsafe extern "C" {
    pub fn HTTP_estimate(nhttp: ::std::ffi::c_uint) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn HTTP_Clone(to: *mut http, fm: *const http);
}
unsafe extern "C" {
    pub fn HTTP_Dup(to: *mut http, fm: *const http);
}
unsafe extern "C" {
    pub fn HTTP_create(
        p: *mut ::std::ffi::c_void,
        nhttp: u16,
        arg1: ::std::ffi::c_uint,
    ) -> *mut http;
}
unsafe extern "C" {
    pub fn http_Status2Reason(
        arg1: ::std::ffi::c_uint,
        arg2: *mut *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn http_IsHdr(hh: *const txt, hdr: hdr_t) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_EstimateWS(fm: *const http, how: ::std::ffi::c_uint) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn http_PutResponse(
        to: *mut http,
        proto: *const ::std::ffi::c_char,
        status: u16,
        response: *const ::std::ffi::c_char,
    );
}
unsafe extern "C" {
    pub fn http_FilterReq(to: *mut http, fm: *const http, how: ::std::ffi::c_uint);
}
unsafe extern "C" {
    pub fn HTTP_Encode(
        fm: *const http,
        arg1: *mut u8,
        len: ::std::ffi::c_uint,
        how: ::std::ffi::c_uint,
    );
}
unsafe extern "C" {
    pub fn HTTP_Decode(to: *mut http, fm: *const u8) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_ForceHeader(to: *mut http, arg1: hdr_t, val: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_AppendHeader(to: *mut http, arg1: hdr_t, val: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_PrintfHeader(to: *mut http, fmt: *const ::std::ffi::c_char, ...);
}
unsafe extern "C" {
    pub fn http_TimeHeader(to: *mut http, fmt: *const ::std::ffi::c_char, now: vtim_real);
}
unsafe extern "C" {
    pub fn http_ViaHeader() -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn http_Proto(to: *mut http);
}
unsafe extern "C" {
    pub fn http_SetHeader(to: *mut http, header: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_SetH(to: *mut http, n: ::std::ffi::c_uint, header: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_ForceField(to: *mut http, n: ::std::ffi::c_uint, t: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn HTTP_Setup(arg1: *mut http, arg2: *mut ws, arg3: *mut vsl_log, arg4: VslTag);
}
unsafe extern "C" {
    pub fn http_Teardown(ht: *mut http);
}
unsafe extern "C" {
    pub fn http_GetHdr(
        hp: *const http,
        arg1: hdr_t,
        ptr: *mut *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_GetHdrToken(
        hp: *const http,
        arg1: hdr_t,
        token: *const ::std::ffi::c_char,
        pb: *mut *const ::std::ffi::c_char,
        pe: *mut *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_GetHdrField(
        hp: *const http,
        arg1: hdr_t,
        field: *const ::std::ffi::c_char,
        ptr: *mut *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_GetHdrQ(hp: *const http, arg1: hdr_t, field: *const ::std::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn http_GetContentLength(hp: *const http) -> isize;
}
unsafe extern "C" {
    pub fn http_GetContentRange(hp: *const http, lo: *mut isize, hi: *mut isize) -> isize;
}
unsafe extern "C" {
    pub fn http_GetRange(
        hp: *const http,
        lo: *mut isize,
        hi: *mut isize,
        len: isize,
    ) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn http_GetStatus(hp: *const http) -> u16;
}
unsafe extern "C" {
    pub fn http_IsStatus(hp: *const http, arg1: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_SetStatus(to: *mut http, status: u16, reason: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_GetMethod(hp: *const http) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn http_HdrIs(
        hp: *const http,
        arg1: hdr_t,
        val: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn http_CopyHome(hp: *const http);
}
unsafe extern "C" {
    pub fn http_Unset(hp: *mut http, arg1: hdr_t);
}
unsafe extern "C" {
    pub fn http_CountHdr(hp: *const http, arg1: hdr_t) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn http_CollectHdr(hp: *mut http, arg1: hdr_t);
}
unsafe extern "C" {
    pub fn http_CollectHdrSep(hp: *mut http, arg1: hdr_t, sep: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn http_VSL_log(hp: *const http);
}
unsafe extern "C" {
    pub fn HTTP_Merge(arg1: *mut worker, arg2: *mut objcore, to: *mut http);
}
unsafe extern "C" {
    pub fn HTTP_GetStatusPack(arg1: *mut worker, oc: *mut objcore) -> u16;
}
unsafe extern "C" {
    pub fn HTTP_IterHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: *mut *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn HTTP_GetHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: hdr_t,
    ) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn http_DoConnection(hp: *mut http, sc_close: stream_close_t) -> stream_close_t;
}
unsafe extern "C" {
    pub fn http_IsFiltered(
        hp: *const http,
        u: ::std::ffi::c_uint,
        how: ::std::ffi::c_uint,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub static mut H_Accept: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Accept_Charset: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Accept_Encoding: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Accept_Language: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Accept_Ranges: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Age: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Allow: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Authorization: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Cache_Control: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Connection: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Encoding: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Language: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Length: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Location: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_MD5: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Range: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Content_Type: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Cookie: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Date: hdr_t;
}
unsafe extern "C" {
    pub static mut H_ETag: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Expect: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Expires: hdr_t;
}
unsafe extern "C" {
    pub static mut H_From: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Host: hdr_t;
}
unsafe extern "C" {
    pub static mut H_HTTP2_Settings: hdr_t;
}
unsafe extern "C" {
    pub static mut H_If_Match: hdr_t;
}
unsafe extern "C" {
    pub static mut H_If_Modified_Since: hdr_t;
}
unsafe extern "C" {
    pub static mut H_If_None_Match: hdr_t;
}
unsafe extern "C" {
    pub static mut H_If_Range: hdr_t;
}
unsafe extern "C" {
    pub static mut H_If_Unmodified_Since: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Keep_Alive: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Last_Modified: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Location: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Max_Forwards: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Pragma: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Proxy_Authenticate: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Proxy_Authorization: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Range: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Referer: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Retry_After: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Server: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Set_Cookie: hdr_t;
}
unsafe extern "C" {
    pub static mut H_TE: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Trailer: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Transfer_Encoding: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Upgrade: hdr_t;
}
unsafe extern "C" {
    pub static mut H_User_Agent: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Vary: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Via: hdr_t;
}
unsafe extern "C" {
    pub static mut H_Warning: hdr_t;
}
unsafe extern "C" {
    pub static mut H_WWW_Authenticate: hdr_t;
}
unsafe extern "C" {
    pub static mut H_X_Forwarded_For: hdr_t;
}
unsafe extern "C" {
    pub static mut H__Status: hdr_t;
}
unsafe extern "C" {
    pub static mut H__Proto: hdr_t;
}
unsafe extern "C" {
    pub static mut H__Reason: hdr_t;
}
unsafe extern "C" {
    pub fn Lck__Lock(lck: *mut lock, p: *const ::std::ffi::c_char, l: ::std::ffi::c_int);
}
unsafe extern "C" {
    pub fn Lck__Unlock(lck: *mut lock, p: *const ::std::ffi::c_char, l: ::std::ffi::c_int);
}
unsafe extern "C" {
    pub fn Lck__Trylock(
        lck: *mut lock,
        p: *const ::std::ffi::c_char,
        l: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn Lck__New(lck: *mut lock, arg1: *mut VSC_lck, arg2: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn Lck__Held(lck: *const lock) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn Lck__Owned(lck: *const lock) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub static mut mtxattr_errorcheck: pthread_mutexattr_t;
}
unsafe extern "C" {
    pub fn Lck_Delete(lck: *mut lock);
}
unsafe extern "C" {
    pub fn Lck_CondWaitUntil(
        arg1: *mut pthread_cond_t,
        arg2: *mut lock,
        when: vtim_real,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn Lck_CondWait(arg1: *mut pthread_cond_t, arg2: *mut lock) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn Lck_CondWaitTimeout(
        arg1: *mut pthread_cond_t,
        arg2: *mut lock,
        timeout: vtim_dur,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn Lck_CreateClass(
        arg1: *mut *mut vsc_seg,
        arg2: *const ::std::ffi::c_char,
    ) -> *mut VSC_lck;
}
unsafe extern "C" {
    pub fn Lck_DestroyClass(arg1: *mut *mut vsc_seg);
}
unsafe extern "C" {
    pub static mut lck_ban: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_busyobj: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_cli: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_director: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_exp: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_hcb: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_lru: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_mempool: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_objhdr: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_perpool: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_pipestat: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_probe: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_sess: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_conn_pool: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_dead_pool: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_vbe: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_vcapace: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_vcashut: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_vcl: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_vxid: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_waiter: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_wq: *mut VSC_lck;
}
unsafe extern "C" {
    pub static mut lck_wstat: *mut VSC_lck;
}
unsafe extern "C" {
    pub fn ObjHasAttr(arg1: *mut worker, arg2: *mut objcore, arg3: obj_attr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjGetAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        len: *mut isize,
    ) -> *const ::std::ffi::c_void;
}
pub type objiterate_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::ffi::c_void,
        flush: ::std::ffi::c_uint,
        ptr: *const ::std::ffi::c_void,
        len: isize,
    ) -> ::std::ffi::c_int,
>;
unsafe extern "C" {
    pub fn ObjIterate(
        arg1: *mut worker,
        arg2: *mut objcore,
        priv_: *mut ::std::ffi::c_void,
        func: objiterate_f,
        final_: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjGetXID(arg1: *mut worker, arg2: *mut objcore) -> vxid_t;
}
unsafe extern "C" {
    pub fn ObjGetLen(arg1: *mut worker, arg2: *mut objcore) -> u64;
}
unsafe extern "C" {
    pub fn ObjGetDouble(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut f64,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjGetU64(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u64,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjCheckFlag(arg1: *mut worker, arg2: *mut objcore, of: obj_flags) -> ::std::ffi::c_int;
}
pub type vai_hdl = *mut ::std::ffi::c_void;
pub type vai_notify_cb =
    ::std::option::Option<unsafe extern "C" fn(arg1: vai_hdl, priv_: *mut ::std::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct viov {
    pub lease: u64,
    pub iov: iovec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of viov"][::std::mem::size_of::<viov>() - 24usize];
    ["Alignment of viov"][::std::mem::align_of::<viov>() - 8usize];
    ["Offset of field: viov::lease"][::std::mem::offset_of!(viov, lease) - 0usize];
    ["Offset of field: viov::iov"][::std::mem::offset_of!(viov, iov) - 8usize];
};
impl Default for viov {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct vscarab {
    pub magic: ::std::ffi::c_uint,
    pub flags: ::std::ffi::c_uint,
    pub capacity: ::std::ffi::c_uint,
    pub used: ::std::ffi::c_uint,
    pub s: __IncompleteArrayField<viov>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vscarab"][::std::mem::size_of::<vscarab>() - 16usize];
    ["Alignment of vscarab"][::std::mem::align_of::<vscarab>() - 8usize];
    ["Offset of field: vscarab::magic"][::std::mem::offset_of!(vscarab, magic) - 0usize];
    ["Offset of field: vscarab::flags"][::std::mem::offset_of!(vscarab, flags) - 4usize];
    ["Offset of field: vscarab::capacity"][::std::mem::offset_of!(vscarab, capacity) - 8usize];
    ["Offset of field: vscarab::used"][::std::mem::offset_of!(vscarab, used) - 12usize];
    ["Offset of field: vscarab::s"][::std::mem::offset_of!(vscarab, s) - 16usize];
};
impl Default for vscarab {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vscaret {
    pub magic: ::std::ffi::c_uint,
    pub capacity: ::std::ffi::c_uint,
    pub used: ::std::ffi::c_uint,
    pub lease: __IncompleteArrayField<::std::ffi::c_ulonglong>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vscaret"][::std::mem::size_of::<vscaret>() - 16usize];
    ["Alignment of vscaret"][::std::mem::align_of::<vscaret>() - 8usize];
    ["Offset of field: vscaret::magic"][::std::mem::offset_of!(vscaret, magic) - 0usize];
    ["Offset of field: vscaret::capacity"][::std::mem::offset_of!(vscaret, capacity) - 4usize];
    ["Offset of field: vscaret::used"][::std::mem::offset_of!(vscaret, used) - 8usize];
    ["Offset of field: vscaret::lease"][::std::mem::offset_of!(vscaret, lease) - 16usize];
};
unsafe extern "C" {
    pub fn ObjVAIinit(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: *mut ws,
        arg4: vai_notify_cb,
        arg5: *mut ::std::ffi::c_void,
    ) -> vai_hdl;
}
unsafe extern "C" {
    pub fn ObjVAIlease(arg1: *mut worker, arg2: vai_hdl, arg3: *mut vscarab) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjVAIbuffer(arg1: *mut worker, arg2: vai_hdl, arg3: *mut vscarab) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn ObjVAIreturn(arg1: *mut worker, arg2: vai_hdl, arg3: *mut vscaret);
}
unsafe extern "C" {
    pub fn ObjVAIfini(arg1: *mut worker, arg2: *mut vai_hdl);
}
unsafe extern "C" {
    pub fn VRB_Iterate(
        arg1: *mut worker,
        arg2: *mut vsl_log,
        arg3: *mut req,
        func: objiterate_f,
        priv_: *mut ::std::ffi::c_void,
    ) -> isize;
}
unsafe extern "C" {
    pub fn SES_Get_transport(
        sp: *const sess,
        dst: *mut *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_remote_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_local_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_client_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_server_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_client_ip(
        sp: *const sess,
        dst: *mut *mut ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_client_port(
        sp: *const sess,
        dst: *mut *mut ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_proxy_tlv(sp: *const sess, dst: *mut *mut usize) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_proto_priv(sp: *const sess, dst: *mut *mut usize) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn SES_Get_String_Attr(sp: *const sess, a: SessionAttr) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn VSLv(tag: VslTag, vxid: vxid_t, fmt: *const ::std::ffi::c_char, va: va_list);
}
unsafe extern "C" {
    pub fn VSL(tag: VslTag, vxid: vxid_t, fmt: *const ::std::ffi::c_char, ...);
}
unsafe extern "C" {
    pub fn VSLs(tag: VslTag, vxid: vxid_t, s: *const strands);
}
unsafe extern "C" {
    pub fn VSLbv(arg1: *mut vsl_log, tag: VslTag, fmt: *const ::std::ffi::c_char, va: va_list);
}
unsafe extern "C" {
    pub fn VSLb(arg1: *mut vsl_log, tag: VslTag, fmt: *const ::std::ffi::c_char, ...);
}
unsafe extern "C" {
    pub fn VSLbt(arg1: *mut vsl_log, tag: VslTag, t: txt);
}
unsafe extern "C" {
    pub fn VSLbs(arg1: *mut vsl_log, tag: VslTag, s: *const strands);
}
unsafe extern "C" {
    pub fn VSLb_ts(
        arg1: *mut vsl_log,
        event: *const ::std::ffi::c_char,
        first: vtim_real,
        pprev: *mut vtim_real,
        now: vtim_real,
    );
}
unsafe extern "C" {
    pub fn VSLb_bin(arg1: *mut vsl_log, arg2: VslTag, arg3: isize, arg4: *const ::std::ffi::c_void);
}
unsafe extern "C" {
    pub fn VSL_tag_is_masked(tag: VslTag) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VCL_Name(arg1: *const vcl) -> *const ::std::ffi::c_char;
}
pub type bgthread_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut worker,
        priv_: *mut ::std::ffi::c_void,
    ) -> *mut ::std::ffi::c_void,
>;
unsafe extern "C" {
    pub fn WRK_BgThread(
        thr: *mut pthread_t,
        name: *const ::std::ffi::c_char,
        func: bgthread_t,
        priv_: *mut ::std::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn WS_Init(
        ws: *mut ws,
        id: *const ::std::ffi::c_char,
        space: *mut ::std::ffi::c_void,
        len: ::std::ffi::c_uint,
    );
}
unsafe extern "C" {
    pub fn WS_ReserveSize(arg1: *mut ws, arg2: ::std::ffi::c_uint) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn WS_ReserveAll(arg1: *mut ws) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn WS_Release(ws: *mut ws, bytes: ::std::ffi::c_uint);
}
unsafe extern "C" {
    pub fn WS_ReleaseP(ws: *mut ws, ptr: *const ::std::ffi::c_char);
}
unsafe extern "C" {
    pub fn WS_Assert(ws: *const ws);
}
unsafe extern "C" {
    pub fn WS_Reset(ws: *mut ws, arg1: usize);
}
unsafe extern "C" {
    pub fn WS_Alloc(ws: *mut ws, bytes: ::std::ffi::c_uint) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn WS_Copy(
        ws: *mut ws,
        str_: *const ::std::ffi::c_void,
        len: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn WS_Snapshot(ws: *mut ws) -> usize;
}
unsafe extern "C" {
    pub fn WS_Allocated(
        ws: *const ws,
        ptr: *const ::std::ffi::c_void,
        len: isize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn WS_Dump(
        ws: *const ws,
        arg1: ::std::ffi::c_char,
        off: usize,
        buf: *mut ::std::ffi::c_void,
        len: usize,
    ) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn WS_MarkOverflow(ws: *mut ws);
}
unsafe extern "C" {
    pub fn WS_Overflowed(ws: *const ws) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn WS_Printf(ws: *mut ws, fmt: *const ::std::ffi::c_char, ...)
    -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn WS_VSB_new(arg1: *mut vsb, arg2: *mut ws);
}
unsafe extern "C" {
    pub fn WS_VSB_finish(
        arg1: *mut vsb,
        arg2: *mut ws,
        arg3: *mut usize,
    ) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn RFC2616_Ttl(
        arg1: *mut busyobj,
        now: vtim_real,
        t_origin: *mut vtim_real,
        ttl: *mut f32,
        grace: *mut f32,
        keep: *mut f32,
    );
}
unsafe extern "C" {
    pub fn RFC2616_Req_Gzip(arg1: *const http) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn RFC2616_Do_Cond(sp: *const req) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn RFC2616_Weaken_Etag(hp: *mut http);
}
unsafe extern "C" {
    pub fn RFC2616_Vary_AE(hp: *mut http);
}
unsafe extern "C" {
    pub fn RFC2616_Strong_LM(
        hp: *const http,
        wrk: *mut worker,
        oc: *mut objcore,
    ) -> *const ::std::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir {
    pub magic: ::std::ffi::c_uint,
    pub refcnt: ::std::ffi::c_int,
    pub flags: ::std::ffi::c_uint,
    pub dlck: lock,
    pub dir: *mut director,
    pub vcl: *mut vcl,
    pub methods: *const vdi_methods,
    pub directors_list: vcldir__bindgen_ty_1,
    pub resigning_list: vcldir__bindgen_ty_2,
    pub admin_health: *mut vdi_ahealth,
    pub health_changed: vtim_real,
    pub cli_name: *mut ::std::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir__bindgen_ty_1 {
    pub vtqe_next: *mut vcldir,
    pub vtqe_prev: *mut *mut vcldir,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vcldir__bindgen_ty_1"][::std::mem::size_of::<vcldir__bindgen_ty_1>() - 16usize];
    ["Alignment of vcldir__bindgen_ty_1"][::std::mem::align_of::<vcldir__bindgen_ty_1>() - 8usize];
    ["Offset of field: vcldir__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(vcldir__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: vcldir__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(vcldir__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for vcldir__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir__bindgen_ty_2 {
    pub vtqe_next: *mut vcldir,
    pub vtqe_prev: *mut *mut vcldir,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vcldir__bindgen_ty_2"][::std::mem::size_of::<vcldir__bindgen_ty_2>() - 16usize];
    ["Alignment of vcldir__bindgen_ty_2"][::std::mem::align_of::<vcldir__bindgen_ty_2>() - 8usize];
    ["Offset of field: vcldir__bindgen_ty_2::vtqe_next"]
        [::std::mem::offset_of!(vcldir__bindgen_ty_2, vtqe_next) - 0usize];
    ["Offset of field: vcldir__bindgen_ty_2::vtqe_prev"]
        [::std::mem::offset_of!(vcldir__bindgen_ty_2, vtqe_prev) - 8usize];
};
impl Default for vcldir__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vcldir"][::std::mem::size_of::<vcldir>() - 104usize];
    ["Alignment of vcldir"][::std::mem::align_of::<vcldir>() - 8usize];
    ["Offset of field: vcldir::magic"][::std::mem::offset_of!(vcldir, magic) - 0usize];
    ["Offset of field: vcldir::refcnt"][::std::mem::offset_of!(vcldir, refcnt) - 4usize];
    ["Offset of field: vcldir::flags"][::std::mem::offset_of!(vcldir, flags) - 8usize];
    ["Offset of field: vcldir::dlck"][::std::mem::offset_of!(vcldir, dlck) - 16usize];
    ["Offset of field: vcldir::dir"][::std::mem::offset_of!(vcldir, dir) - 24usize];
    ["Offset of field: vcldir::vcl"][::std::mem::offset_of!(vcldir, vcl) - 32usize];
    ["Offset of field: vcldir::methods"][::std::mem::offset_of!(vcldir, methods) - 40usize];
    ["Offset of field: vcldir::directors_list"]
        [::std::mem::offset_of!(vcldir, directors_list) - 48usize];
    ["Offset of field: vcldir::resigning_list"]
        [::std::mem::offset_of!(vcldir, resigning_list) - 64usize];
    ["Offset of field: vcldir::admin_health"]
        [::std::mem::offset_of!(vcldir, admin_health) - 80usize];
    ["Offset of field: vcldir::health_changed"]
        [::std::mem::offset_of!(vcldir, health_changed) - 88usize];
    ["Offset of field: vcldir::cli_name"][::std::mem::offset_of!(vcldir, cli_name) - 96usize];
};
impl Default for vcldir {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static VDI_AH_HEALTHY: *const vdi_ahealth;
}
unsafe extern "C" {
    pub static VDI_AH_SICK: *const vdi_ahealth;
}
unsafe extern "C" {
    pub static VDI_AH_AUTO: *const vdi_ahealth;
}
unsafe extern "C" {
    pub static VDI_AH_DELETED: *const vdi_ahealth;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VfpStatus {
    Error = -1,
    Ok = 0,
    End = 1,
    Null = 2,
}
pub type vfp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
    ) -> VfpStatus,
>;
pub type vfp_pull_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
        ptr: *mut ::std::ffi::c_void,
        len: *mut isize,
    ) -> VfpStatus,
>;
pub type vfp_fini_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp {
    pub name: *const ::std::ffi::c_char,
    pub init: vfp_init_f,
    pub pull: vfp_pull_f,
    pub fini: vfp_fini_f,
    pub priv1: *const ::std::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfp"][::std::mem::size_of::<vfp>() - 40usize];
    ["Alignment of vfp"][::std::mem::align_of::<vfp>() - 8usize];
    ["Offset of field: vfp::name"][::std::mem::offset_of!(vfp, name) - 0usize];
    ["Offset of field: vfp::init"][::std::mem::offset_of!(vfp, init) - 8usize];
    ["Offset of field: vfp::pull"][::std::mem::offset_of!(vfp, pull) - 16usize];
    ["Offset of field: vfp::fini"][::std::mem::offset_of!(vfp, fini) - 24usize];
    ["Offset of field: vfp::priv1"][::std::mem::offset_of!(vfp, priv1) - 32usize];
};
impl Default for vfp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry {
    pub magic: ::std::ffi::c_uint,
    pub closed: VfpStatus,
    pub vfp: *const vfp,
    pub priv1: *mut ::std::ffi::c_void,
    pub priv2: isize,
    pub list: vfp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_out: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vfp_entry,
    pub vtqe_prev: *mut *mut vfp_entry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfp_entry__bindgen_ty_1"][::std::mem::size_of::<vfp_entry__bindgen_ty_1>() - 16usize];
    ["Alignment of vfp_entry__bindgen_ty_1"]
        [::std::mem::align_of::<vfp_entry__bindgen_ty_1>() - 8usize];
    ["Offset of field: vfp_entry__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(vfp_entry__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: vfp_entry__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(vfp_entry__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for vfp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfp_entry"][::std::mem::size_of::<vfp_entry>() - 64usize];
    ["Alignment of vfp_entry"][::std::mem::align_of::<vfp_entry>() - 8usize];
    ["Offset of field: vfp_entry::magic"][::std::mem::offset_of!(vfp_entry, magic) - 0usize];
    ["Offset of field: vfp_entry::closed"][::std::mem::offset_of!(vfp_entry, closed) - 4usize];
    ["Offset of field: vfp_entry::vfp"][::std::mem::offset_of!(vfp_entry, vfp) - 8usize];
    ["Offset of field: vfp_entry::priv1"][::std::mem::offset_of!(vfp_entry, priv1) - 16usize];
    ["Offset of field: vfp_entry::priv2"][::std::mem::offset_of!(vfp_entry, priv2) - 24usize];
    ["Offset of field: vfp_entry::list"][::std::mem::offset_of!(vfp_entry, list) - 32usize];
    ["Offset of field: vfp_entry::calls"][::std::mem::offset_of!(vfp_entry, calls) - 48usize];
    ["Offset of field: vfp_entry::bytes_out"]
        [::std::mem::offset_of!(vfp_entry, bytes_out) - 56usize];
};
impl Default for vfp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry_s {
    pub vtqh_first: *mut vfp_entry,
    pub vtqh_last: *mut *mut vfp_entry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfp_entry_s"][::std::mem::size_of::<vfp_entry_s>() - 16usize];
    ["Alignment of vfp_entry_s"][::std::mem::align_of::<vfp_entry_s>() - 8usize];
    ["Offset of field: vfp_entry_s::vtqh_first"]
        [::std::mem::offset_of!(vfp_entry_s, vtqh_first) - 0usize];
    ["Offset of field: vfp_entry_s::vtqh_last"]
        [::std::mem::offset_of!(vfp_entry_s, vtqh_last) - 8usize];
};
impl Default for vfp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_ctx {
    pub magic: ::std::ffi::c_uint,
    pub failed: ::std::ffi::c_int,
    pub req: *mut http,
    pub resp: *mut http,
    pub wrk: *mut worker,
    pub oc: *mut objcore,
    pub vfp: vfp_entry_s,
    pub vfp_nxt: *mut vfp_entry,
    pub obj_flags: ::std::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfp_ctx"][::std::mem::size_of::<vfp_ctx>() - 72usize];
    ["Alignment of vfp_ctx"][::std::mem::align_of::<vfp_ctx>() - 8usize];
    ["Offset of field: vfp_ctx::magic"][::std::mem::offset_of!(vfp_ctx, magic) - 0usize];
    ["Offset of field: vfp_ctx::failed"][::std::mem::offset_of!(vfp_ctx, failed) - 4usize];
    ["Offset of field: vfp_ctx::req"][::std::mem::offset_of!(vfp_ctx, req) - 8usize];
    ["Offset of field: vfp_ctx::resp"][::std::mem::offset_of!(vfp_ctx, resp) - 16usize];
    ["Offset of field: vfp_ctx::wrk"][::std::mem::offset_of!(vfp_ctx, wrk) - 24usize];
    ["Offset of field: vfp_ctx::oc"][::std::mem::offset_of!(vfp_ctx, oc) - 32usize];
    ["Offset of field: vfp_ctx::vfp"][::std::mem::offset_of!(vfp_ctx, vfp) - 40usize];
    ["Offset of field: vfp_ctx::vfp_nxt"][::std::mem::offset_of!(vfp_ctx, vfp_nxt) - 56usize];
    ["Offset of field: vfp_ctx::obj_flags"][::std::mem::offset_of!(vfp_ctx, obj_flags) - 64usize];
};
impl Default for vfp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VFP_Suck(arg1: *mut vfp_ctx, p: *mut ::std::ffi::c_void, lp: *mut isize) -> VfpStatus;
}
unsafe extern "C" {
    pub fn VFP_Error(arg1: *mut vfp_ctx, fmt: *const ::std::ffi::c_char, ...) -> VfpStatus;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdpAction {
    Null = 0,
    Flush = 1,
    End = 2,
}
pub type vdp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
pub type vdp_fini_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
pub type vdp_bytes_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        arg2: VdpAction,
        priv_: *mut *mut ::std::ffi::c_void,
        ptr: *const ::std::ffi::c_void,
        len: isize,
    ) -> ::std::ffi::c_int,
>;
pub type vdpio_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::ffi::c_void,
        capacity: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int,
>;
pub type vdpio_lease_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        arg2: *mut vdp_entry,
        scarab: *mut vscarab,
    ) -> ::std::ffi::c_int,
>;
pub type vdpio_fini_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut vdp_ctx, priv_: *mut *mut ::std::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp {
    pub name: *const ::std::ffi::c_char,
    pub init: vdp_init_f,
    pub bytes: vdp_bytes_f,
    pub fini: vdp_fini_f,
    pub priv1: *const ::std::ffi::c_void,
    pub io_init: vdpio_init_f,
    pub io_upgrade: vdpio_init_f,
    pub io_lease: vdpio_lease_f,
    pub io_fini: vdpio_fini_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdp"][::std::mem::size_of::<vdp>() - 72usize];
    ["Alignment of vdp"][::std::mem::align_of::<vdp>() - 8usize];
    ["Offset of field: vdp::name"][::std::mem::offset_of!(vdp, name) - 0usize];
    ["Offset of field: vdp::init"][::std::mem::offset_of!(vdp, init) - 8usize];
    ["Offset of field: vdp::bytes"][::std::mem::offset_of!(vdp, bytes) - 16usize];
    ["Offset of field: vdp::fini"][::std::mem::offset_of!(vdp, fini) - 24usize];
    ["Offset of field: vdp::priv1"][::std::mem::offset_of!(vdp, priv1) - 32usize];
    ["Offset of field: vdp::io_init"][::std::mem::offset_of!(vdp, io_init) - 40usize];
    ["Offset of field: vdp::io_upgrade"][::std::mem::offset_of!(vdp, io_upgrade) - 48usize];
    ["Offset of field: vdp::io_lease"][::std::mem::offset_of!(vdp, io_lease) - 56usize];
    ["Offset of field: vdp::io_fini"][::std::mem::offset_of!(vdp, io_fini) - 64usize];
};
impl Default for vdp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry {
    pub magic: ::std::ffi::c_uint,
    pub end: VdpAction,
    pub vdp: *const vdp,
    pub priv_: *mut ::std::ffi::c_void,
    pub list: vdp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_in: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vdp_entry,
    pub vtqe_prev: *mut *mut vdp_entry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdp_entry__bindgen_ty_1"][::std::mem::size_of::<vdp_entry__bindgen_ty_1>() - 16usize];
    ["Alignment of vdp_entry__bindgen_ty_1"]
        [::std::mem::align_of::<vdp_entry__bindgen_ty_1>() - 8usize];
    ["Offset of field: vdp_entry__bindgen_ty_1::vtqe_next"]
        [::std::mem::offset_of!(vdp_entry__bindgen_ty_1, vtqe_next) - 0usize];
    ["Offset of field: vdp_entry__bindgen_ty_1::vtqe_prev"]
        [::std::mem::offset_of!(vdp_entry__bindgen_ty_1, vtqe_prev) - 8usize];
};
impl Default for vdp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdp_entry"][::std::mem::size_of::<vdp_entry>() - 56usize];
    ["Alignment of vdp_entry"][::std::mem::align_of::<vdp_entry>() - 8usize];
    ["Offset of field: vdp_entry::magic"][::std::mem::offset_of!(vdp_entry, magic) - 0usize];
    ["Offset of field: vdp_entry::end"][::std::mem::offset_of!(vdp_entry, end) - 4usize];
    ["Offset of field: vdp_entry::vdp"][::std::mem::offset_of!(vdp_entry, vdp) - 8usize];
    ["Offset of field: vdp_entry::priv_"][::std::mem::offset_of!(vdp_entry, priv_) - 16usize];
    ["Offset of field: vdp_entry::list"][::std::mem::offset_of!(vdp_entry, list) - 24usize];
    ["Offset of field: vdp_entry::calls"][::std::mem::offset_of!(vdp_entry, calls) - 40usize];
    ["Offset of field: vdp_entry::bytes_in"][::std::mem::offset_of!(vdp_entry, bytes_in) - 48usize];
};
impl Default for vdp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry_s {
    pub vtqh_first: *mut vdp_entry,
    pub vtqh_last: *mut *mut vdp_entry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdp_entry_s"][::std::mem::size_of::<vdp_entry_s>() - 16usize];
    ["Alignment of vdp_entry_s"][::std::mem::align_of::<vdp_entry_s>() - 8usize];
    ["Offset of field: vdp_entry_s::vtqh_first"]
        [::std::mem::offset_of!(vdp_entry_s, vtqh_first) - 0usize];
    ["Offset of field: vdp_entry_s::vtqh_last"]
        [::std::mem::offset_of!(vdp_entry_s, vtqh_last) - 8usize];
};
impl Default for vdp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_ctx {
    pub magic: ::std::ffi::c_uint,
    pub retval: ::std::ffi::c_int,
    pub bytes_done: u64,
    pub vdp: vdp_entry_s,
    pub nxt: *mut vdp_entry,
    pub wrk: *mut worker,
    pub vsl: *mut vsl_log,
    pub oc: *mut objcore,
    pub hp: *mut http,
    pub clen: *mut intmax_t,
    pub vai_hdl: vai_hdl,
    pub scaret: *mut vscaret,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vdp_ctx"][::std::mem::size_of::<vdp_ctx>() - 96usize];
    ["Alignment of vdp_ctx"][::std::mem::align_of::<vdp_ctx>() - 8usize];
    ["Offset of field: vdp_ctx::magic"][::std::mem::offset_of!(vdp_ctx, magic) - 0usize];
    ["Offset of field: vdp_ctx::retval"][::std::mem::offset_of!(vdp_ctx, retval) - 4usize];
    ["Offset of field: vdp_ctx::bytes_done"][::std::mem::offset_of!(vdp_ctx, bytes_done) - 8usize];
    ["Offset of field: vdp_ctx::vdp"][::std::mem::offset_of!(vdp_ctx, vdp) - 16usize];
    ["Offset of field: vdp_ctx::nxt"][::std::mem::offset_of!(vdp_ctx, nxt) - 32usize];
    ["Offset of field: vdp_ctx::wrk"][::std::mem::offset_of!(vdp_ctx, wrk) - 40usize];
    ["Offset of field: vdp_ctx::vsl"][::std::mem::offset_of!(vdp_ctx, vsl) - 48usize];
    ["Offset of field: vdp_ctx::oc"][::std::mem::offset_of!(vdp_ctx, oc) - 56usize];
    ["Offset of field: vdp_ctx::hp"][::std::mem::offset_of!(vdp_ctx, hp) - 64usize];
    ["Offset of field: vdp_ctx::clen"][::std::mem::offset_of!(vdp_ctx, clen) - 72usize];
    ["Offset of field: vdp_ctx::vai_hdl"][::std::mem::offset_of!(vdp_ctx, vai_hdl) - 80usize];
    ["Offset of field: vdp_ctx::scaret"][::std::mem::offset_of!(vdp_ctx, scaret) - 88usize];
};
impl Default for vdp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VDP_bytes(
        arg1: *mut vdp_ctx,
        act: VdpAction,
        arg2: *const ::std::ffi::c_void,
        arg3: isize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VDPIO_Close1(arg1: *mut vdp_ctx, vdpe: *mut vdp_entry) -> u64;
}
unsafe extern "C" {
    pub fn VDPIO_Init(
        vdc: *mut vdp_ctx,
        oc: *mut objcore,
        ws: *mut ws,
        notify_cb: vai_notify_cb,
        notify_priv: *mut ::std::ffi::c_void,
        scaret: *mut vscaret,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VDPIO_Return(vdc: *const vdp_ctx);
}
unsafe extern "C" {
    pub fn VDPIO_Fini(vdc: *mut vdp_ctx);
}
unsafe extern "C" {
    pub fn VRT_AddFilter(
        ctx: *const vrt_ctx,
        arg1: *const vfp,
        arg2: *const vdp,
    ) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn VRT_RemoveFilter(ctx: *const vrt_ctx, arg1: *const vfp, arg2: *const vdp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsb {
    pub magic: ::std::ffi::c_uint,
    pub s_error: ::std::ffi::c_int,
    pub s_buf: *mut ::std::ffi::c_char,
    pub s_size: isize,
    pub s_len: isize,
    pub s_flags: ::std::ffi::c_int,
    pub s_indent: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsb"][::std::mem::size_of::<vsb>() - 40usize];
    ["Alignment of vsb"][::std::mem::align_of::<vsb>() - 8usize];
    ["Offset of field: vsb::magic"][::std::mem::offset_of!(vsb, magic) - 0usize];
    ["Offset of field: vsb::s_error"][::std::mem::offset_of!(vsb, s_error) - 4usize];
    ["Offset of field: vsb::s_buf"][::std::mem::offset_of!(vsb, s_buf) - 8usize];
    ["Offset of field: vsb::s_size"][::std::mem::offset_of!(vsb, s_size) - 16usize];
    ["Offset of field: vsb::s_len"][::std::mem::offset_of!(vsb, s_len) - 24usize];
    ["Offset of field: vsb::s_flags"][::std::mem::offset_of!(vsb, s_flags) - 32usize];
    ["Offset of field: vsb::s_indent"][::std::mem::offset_of!(vsb, s_indent) - 36usize];
};
impl Default for vsb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VSB_init(arg1: *mut vsb, arg2: *mut ::std::ffi::c_void, arg3: isize) -> *mut vsb;
}
unsafe extern "C" {
    pub fn VSB_new_auto() -> *mut vsb;
}
unsafe extern "C" {
    pub fn VSB_clear(arg1: *mut vsb);
}
unsafe extern "C" {
    pub fn VSB_bcat(
        arg1: *mut vsb,
        arg2: *const ::std::ffi::c_void,
        arg3: isize,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_cat(arg1: *mut vsb, arg2: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_printf(arg1: *mut vsb, arg2: *const ::std::ffi::c_char, ...) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_vprintf(
        arg1: *mut vsb,
        arg2: *const ::std::ffi::c_char,
        arg3: va_list,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_putc(arg1: *mut vsb, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_error(arg1: *const vsb) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_finish(arg1: *mut vsb) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSB_data(arg1: *const vsb) -> *mut ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn VSB_len(arg1: *const vsb) -> isize;
}
unsafe extern "C" {
    pub fn VSB_fini(arg1: *mut vsb);
}
unsafe extern "C" {
    pub fn VSB_destroy(arg1: *mut *mut vsb);
}
unsafe extern "C" {
    pub fn VSB_quote_pfx(
        arg1: *mut vsb,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_void,
        len: ::std::ffi::c_int,
        how: ::std::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn VSB_quote(
        arg1: *mut vsb,
        arg2: *const ::std::ffi::c_void,
        len: ::std::ffi::c_int,
        how: ::std::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn VSB_indent(arg1: *mut vsb, arg2: ::std::ffi::c_int);
}
unsafe extern "C" {
    pub fn VSB_tofile(arg1: *const vsb, fd: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub static vsa_suckaddr_len: usize;
}
unsafe extern "C" {
    pub static mut bogo_ip: *const suckaddr;
}
unsafe extern "C" {
    pub static mut bogo_ip6: *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_Init();
}
unsafe extern "C" {
    pub fn VSA_Sane(arg1: *const suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSA_Port(arg1: *const suckaddr) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn VSA_Compare(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSA_Compare_IP(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSA_Clone(sua: *const suckaddr) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_getsockname(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_void,
        arg3: usize,
    ) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_getpeername(
        arg1: ::std::ffi::c_int,
        arg2: *mut ::std::ffi::c_void,
        arg3: usize,
    ) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_free(arg1: *mut *const suckaddr);
}
unsafe extern "C" {
    pub fn VSA_Get_Sockaddr(arg1: *const suckaddr, sl: *mut socklen_t)
    -> *const ::std::ffi::c_void;
}
unsafe extern "C" {
    pub fn VSA_Get_Proto(arg1: *const suckaddr) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSA_Malloc(s: *const ::std::ffi::c_void, sal: ::std::ffi::c_uint) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_Build(
        d: *mut ::std::ffi::c_void,
        s: *const ::std::ffi::c_void,
        sal: ::std::ffi::c_uint,
    ) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_BuildFAP(
        d: *mut ::std::ffi::c_void,
        fam: sa_family_t,
        a: *const ::std::ffi::c_void,
        al: ::std::ffi::c_uint,
        p: *const ::std::ffi::c_void,
        pl: ::std::ffi::c_uint,
    ) -> *const suckaddr;
}
unsafe extern "C" {
    pub fn VSA_GetPtr(
        sua: *const suckaddr,
        dst: *mut *const ::std::ffi::c_uchar,
    ) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm_fantom {
    pub priv_: usize,
    pub priv2: usize,
    pub b: *mut ::std::ffi::c_void,
    pub e: *mut ::std::ffi::c_void,
    pub category: *mut ::std::ffi::c_char,
    pub ident: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsm_fantom"][::std::mem::size_of::<vsm_fantom>() - 48usize];
    ["Alignment of vsm_fantom"][::std::mem::align_of::<vsm_fantom>() - 8usize];
    ["Offset of field: vsm_fantom::priv_"][::std::mem::offset_of!(vsm_fantom, priv_) - 0usize];
    ["Offset of field: vsm_fantom::priv2"][::std::mem::offset_of!(vsm_fantom, priv2) - 8usize];
    ["Offset of field: vsm_fantom::b"][::std::mem::offset_of!(vsm_fantom, b) - 16usize];
    ["Offset of field: vsm_fantom::e"][::std::mem::offset_of!(vsm_fantom, e) - 24usize];
    ["Offset of field: vsm_fantom::category"]
        [::std::mem::offset_of!(vsm_fantom, category) - 32usize];
    ["Offset of field: vsm_fantom::ident"][::std::mem::offset_of!(vsm_fantom, ident) - 40usize];
};
impl Default for vsm_fantom {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VSM_New() -> *mut vsm;
}
unsafe extern "C" {
    pub fn VSM_Destroy(vd: *mut *mut vsm);
}
unsafe extern "C" {
    pub fn VSM_Error(vd: *const vsm) -> *const ::std::ffi::c_char;
}
unsafe extern "C" {
    pub fn VSM_ResetError(vd: *mut vsm);
}
unsafe extern "C" {
    pub fn VSM_Arg(
        arg1: *mut vsm,
        flag: ::std::ffi::c_char,
        arg: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSM_Attach(arg1: *mut vsm, progress: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSM_Status(arg1: *mut vsm) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn VSM__iter0(arg1: *const vsm, vf: *mut vsm_fantom);
}
unsafe extern "C" {
    pub fn VSM__itern(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSM_Map(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSM_Unmap(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm_valid {
    pub name: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsm_valid"][::std::mem::size_of::<vsm_valid>() - 8usize];
    ["Alignment of vsm_valid"][::std::mem::align_of::<vsm_valid>() - 8usize];
    ["Offset of field: vsm_valid::name"][::std::mem::offset_of!(vsm_valid, name) - 0usize];
};
impl Default for vsm_valid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static VSM_invalid: [vsm_valid; 0usize];
}
unsafe extern "C" {
    pub static VSM_valid: [vsm_valid; 0usize];
}
unsafe extern "C" {
    pub fn VSM_StillValid(arg1: *const vsm, vf: *const vsm_fantom) -> *const vsm_valid;
}
unsafe extern "C" {
    pub fn VSM_Get(
        arg1: *mut vsm,
        vf: *mut vsm_fantom,
        category: *const ::std::ffi::c_char,
        ident: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSM_Dup(
        arg1: *mut vsm,
        category: *const ::std::ffi::c_char,
        ident: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_level_desc {
    pub name: *const ::std::ffi::c_char,
    pub label: *const ::std::ffi::c_char,
    pub sdesc: *const ::std::ffi::c_char,
    pub ldesc: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VSC_level_desc"][::std::mem::size_of::<VSC_level_desc>() - 32usize];
    ["Alignment of VSC_level_desc"][::std::mem::align_of::<VSC_level_desc>() - 8usize];
    ["Offset of field: VSC_level_desc::name"]
        [::std::mem::offset_of!(VSC_level_desc, name) - 0usize];
    ["Offset of field: VSC_level_desc::label"]
        [::std::mem::offset_of!(VSC_level_desc, label) - 8usize];
    ["Offset of field: VSC_level_desc::sdesc"]
        [::std::mem::offset_of!(VSC_level_desc, sdesc) - 16usize];
    ["Offset of field: VSC_level_desc::ldesc"]
        [::std::mem::offset_of!(VSC_level_desc, ldesc) - 24usize];
};
impl Default for VSC_level_desc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_point {
    pub ptr: *const u64,
    pub name: *const ::std::ffi::c_char,
    pub ctype: *const ::std::ffi::c_char,
    pub semantics: ::std::ffi::c_int,
    pub format: ::std::ffi::c_int,
    pub level: *const VSC_level_desc,
    pub sdesc: *const ::std::ffi::c_char,
    pub ldesc: *const ::std::ffi::c_char,
    pub priv_: *mut ::std::ffi::c_void,
    pub raw: ::std::ffi::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VSC_point"][::std::mem::size_of::<VSC_point>() - 72usize];
    ["Alignment of VSC_point"][::std::mem::align_of::<VSC_point>() - 8usize];
    ["Offset of field: VSC_point::ptr"][::std::mem::offset_of!(VSC_point, ptr) - 0usize];
    ["Offset of field: VSC_point::name"][::std::mem::offset_of!(VSC_point, name) - 8usize];
    ["Offset of field: VSC_point::ctype"][::std::mem::offset_of!(VSC_point, ctype) - 16usize];
    ["Offset of field: VSC_point::semantics"]
        [::std::mem::offset_of!(VSC_point, semantics) - 24usize];
    ["Offset of field: VSC_point::format"][::std::mem::offset_of!(VSC_point, format) - 28usize];
    ["Offset of field: VSC_point::level"][::std::mem::offset_of!(VSC_point, level) - 32usize];
    ["Offset of field: VSC_point::sdesc"][::std::mem::offset_of!(VSC_point, sdesc) - 40usize];
    ["Offset of field: VSC_point::ldesc"][::std::mem::offset_of!(VSC_point, ldesc) - 48usize];
    ["Offset of field: VSC_point::priv_"][::std::mem::offset_of!(VSC_point, priv_) - 56usize];
    ["Offset of field: VSC_point::raw"][::std::mem::offset_of!(VSC_point, raw) - 64usize];
};
impl Default for VSC_point {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VSC_new_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::ffi::c_void,
        pt: *const VSC_point,
    ) -> *mut ::std::ffi::c_void,
>;
pub type VSC_destroy_f = ::std::option::Option<
    unsafe extern "C" fn(priv_: *mut ::std::ffi::c_void, pt: *const VSC_point),
>;
pub type VSC_iter_f = ::std::option::Option<
    unsafe extern "C" fn(priv_: *mut ::std::ffi::c_void, pt: *const VSC_point) -> ::std::ffi::c_int,
>;
unsafe extern "C" {
    pub fn VSC_New() -> *mut vsc;
}
unsafe extern "C" {
    pub fn VSC_Destroy(arg1: *mut *mut vsc, arg2: *mut vsm);
}
unsafe extern "C" {
    pub fn VSC_Arg(
        arg1: *mut vsc,
        arg: ::std::ffi::c_char,
        opt: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSC_State(
        arg1: *mut vsc,
        arg2: VSC_new_f,
        arg3: VSC_destroy_f,
        arg4: *mut ::std::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn VSC_Iter(
        arg1: *mut vsc,
        arg2: *mut vsm,
        arg3: VSC_iter_f,
        priv_: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
unsafe extern "C" {
    pub fn VSC_ChangeLevel(
        arg1: *const VSC_level_desc,
        arg2: ::std::ffi::c_int,
    ) -> *const VSC_level_desc;
}
unsafe extern "C" {
    pub fn VSC_IsRaw(arg1: *const vsc) -> ::std::ffi::c_uint;
}
unsafe extern "C" {
    pub fn VFP_Push(arg1: *mut vfp_ctx, arg2: *const vfp) -> *mut vfp_entry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_conn {
    pub magic: ::std::ffi::c_uint,
    pub rfd: *mut ::std::ffi::c_int,
    pub doclose: stream_close_t,
    pub body_status: body_status_t,
    pub ws: *mut ws,
    pub rxbuf_b: *mut ::std::ffi::c_char,
    pub rxbuf_e: *mut ::std::ffi::c_char,
    pub pipeline_b: *mut ::std::ffi::c_char,
    pub pipeline_e: *mut ::std::ffi::c_char,
    pub content_length: isize,
    pub priv_: *mut ::std::ffi::c_void,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of http_conn"][::std::mem::size_of::<http_conn>() - 104usize];
    ["Alignment of http_conn"][::std::mem::align_of::<http_conn>() - 8usize];
    ["Offset of field: http_conn::magic"][::std::mem::offset_of!(http_conn, magic) - 0usize];
    ["Offset of field: http_conn::rfd"][::std::mem::offset_of!(http_conn, rfd) - 8usize];
    ["Offset of field: http_conn::doclose"][::std::mem::offset_of!(http_conn, doclose) - 16usize];
    ["Offset of field: http_conn::body_status"]
        [::std::mem::offset_of!(http_conn, body_status) - 24usize];
    ["Offset of field: http_conn::ws"][::std::mem::offset_of!(http_conn, ws) - 32usize];
    ["Offset of field: http_conn::rxbuf_b"][::std::mem::offset_of!(http_conn, rxbuf_b) - 40usize];
    ["Offset of field: http_conn::rxbuf_e"][::std::mem::offset_of!(http_conn, rxbuf_e) - 48usize];
    ["Offset of field: http_conn::pipeline_b"]
        [::std::mem::offset_of!(http_conn, pipeline_b) - 56usize];
    ["Offset of field: http_conn::pipeline_e"]
        [::std::mem::offset_of!(http_conn, pipeline_e) - 64usize];
    ["Offset of field: http_conn::content_length"]
        [::std::mem::offset_of!(http_conn, content_length) - 72usize];
    ["Offset of field: http_conn::priv_"][::std::mem::offset_of!(http_conn, priv_) - 80usize];
    ["Offset of field: http_conn::first_byte_timeout"]
        [::std::mem::offset_of!(http_conn, first_byte_timeout) - 88usize];
    ["Offset of field: http_conn::between_bytes_timeout"]
        [::std::mem::offset_of!(http_conn, between_bytes_timeout) - 96usize];
};
impl Default for http_conn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn VRT_VSC_AllocVariadic(
        vc: *mut vsmw_cluster,
        sg: *mut *mut vsc_seg,
        nm: *const ::std::ffi::c_char,
        sd: usize,
        jp: *const ::std::ffi::c_uchar,
        sj: usize,
        fmt: *const ::std::ffi::c_char,
        ...
    ) -> *mut ::std::ffi::c_void;
}
pub type __builtin_va_list = *mut ::std::ffi::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vrt_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vdi_ahealth {
    pub _address: u8,
}
